// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const commitSession = `-- name: CommitSession :exec
INSERT OR
REPLACE
INTO sessions (token, data, expiry)
VALUES (?1, ?2, ?3)
`

type CommitSessionParams struct {
	Token  string `json:"token"`
	Data   []byte `json:"data"`
	Expiry int64  `json:"expiry"`
}

func (q *Queries) CommitSession(ctx context.Context, arg CommitSessionParams) error {
	_, err := q.db.ExecContext(ctx, commitSession, arg.Token, arg.Data, arg.Expiry)
	return err
}

const createComment = `-- name: CreateComment :execlastid

INSERT INTO comments (author, message, ticket)
VALUES (?1, ?2, ?3)
`

type CreateCommentParams struct {
	Author  string `json:"author"`
	Message string `json:"message"`
	Ticket  string `json:"ticket"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createComment, arg.Author, arg.Message, arg.Ticket)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createFeature = `-- name: CreateFeature :execlastid

INSERT INTO features (name)
VALUES (?1)
`

// ----------------------------------------------------------------
func (q *Queries) CreateFeature(ctx context.Context, name string) (int64, error) {
	result, err := q.db.ExecContext(ctx, createFeature, name)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createFile = `-- name: CreateFile :execlastid

INSERT INTO files (name, blob, size, ticket)
VALUES (?1, ?2, ?3, ?4)
`

type CreateFileParams struct {
	Name   string  `json:"name"`
	Blob   string  `json:"blob"`
	Size   float64 `json:"size"`
	Ticket string  `json:"ticket"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createFile,
		arg.Name,
		arg.Blob,
		arg.Size,
		arg.Ticket,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createLink = `-- name: CreateLink :execlastid

INSERT INTO links (name, url, ticket)
VALUES (?1, ?2, ?3)
`

type CreateLinkParams struct {
	Name   string `json:"name"`
	Url    string `json:"url"`
	Ticket string `json:"ticket"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateLink(ctx context.Context, arg CreateLinkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createLink, arg.Name, arg.Url, arg.Ticket)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createReaction = `-- name: CreateReaction :execlastid

INSERT INTO reactions (name, action, actiondata, trigger, triggerdata)
VALUES (?1, ?2, ?3, ?4, ?5)
`

type CreateReactionParams struct {
	Name        string      `json:"name"`
	Action      string      `json:"action"`
	Actiondata  interface{} `json:"actiondata"`
	Trigger     string      `json:"trigger"`
	Triggerdata interface{} `json:"triggerdata"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateReaction(ctx context.Context, arg CreateReactionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createReaction,
		arg.Name,
		arg.Action,
		arg.Actiondata,
		arg.Trigger,
		arg.Triggerdata,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createTask = `-- name: CreateTask :execlastid

INSERT INTO tasks (name, open, owner, ticket)
VALUES (?1, ?2, ?3, ?4)
`

type CreateTaskParams struct {
	Name   string `json:"name"`
	Open   bool   `json:"open"`
	Owner  string `json:"owner"`
	Ticket string `json:"ticket"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createTask,
		arg.Name,
		arg.Open,
		arg.Owner,
		arg.Ticket,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createTicket = `-- name: CreateTicket :execlastid
INSERT INTO tickets (name, description, open, owner, resolution, schema, state, type)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)
`

type CreateTicketParams struct {
	Name        string      `json:"name"`
	Description string      `json:"description"`
	Open        bool        `json:"open"`
	Owner       string      `json:"owner"`
	Resolution  string      `json:"resolution"`
	Schema      interface{} `json:"schema"`
	State       interface{} `json:"state"`
	Type        string      `json:"type"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createTicket,
		arg.Name,
		arg.Description,
		arg.Open,
		arg.Owner,
		arg.Resolution,
		arg.Schema,
		arg.State,
		arg.Type,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createTimeline = `-- name: CreateTimeline :execlastid

INSERT INTO timeline (message, ticket, time)
VALUES (?1, ?2, ?3)
`

type CreateTimelineParams struct {
	Message string `json:"message"`
	Ticket  string `json:"ticket"`
	Time    string `json:"time"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateTimeline(ctx context.Context, arg CreateTimelineParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createTimeline, arg.Message, arg.Ticket, arg.Time)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createType = `-- name: CreateType :execlastid

INSERT INTO types (singular, plural, icon, schema)
VALUES (?1, ?2, ?3, ?4)
`

type CreateTypeParams struct {
	Singular string      `json:"singular"`
	Plural   string      `json:"plural"`
	Icon     string      `json:"icon"`
	Schema   interface{} `json:"schema"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateType(ctx context.Context, arg CreateTypeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createType,
		arg.Singular,
		arg.Plural,
		arg.Icon,
		arg.Schema,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createUser = `-- name: CreateUser :execlastid

INSERT INTO users (name, email, username, passwordHash, tokenKey)
VALUES (?1, ?2, ?3, ?4, ?5)
`

type CreateUserParams struct {
	Name         string `json:"name"`
	Email        string `json:"email"`
	Username     string `json:"username"`
	PasswordHash string `json:"passwordHash"`
	TokenKey     string `json:"tokenKey"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createUser,
		arg.Name,
		arg.Email,
		arg.Username,
		arg.PasswordHash,
		arg.TokenKey,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createWebhook = `-- name: CreateWebhook :execlastid

INSERT INTO webhooks (name, collection, destination)
VALUES (?1, ?2, ?3)
`

type CreateWebhookParams struct {
	Name        string `json:"name"`
	Collection  string `json:"collection"`
	Destination string `json:"destination"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateWebhook(ctx context.Context, arg CreateWebhookParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createWebhook, arg.Name, arg.Collection, arg.Destination)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteComment = `-- name: DeleteComment :exec
DELETE
FROM comments
WHERE id = ?1
`

func (q *Queries) DeleteComment(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteComment, id)
	return err
}

const deleteFeature = `-- name: DeleteFeature :exec
DELETE
FROM features
WHERE id = ?1
`

func (q *Queries) DeleteFeature(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteFeature, id)
	return err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE
FROM files
WHERE id = ?1
`

func (q *Queries) DeleteFile(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteFile, id)
	return err
}

const deleteLink = `-- name: DeleteLink :exec
DELETE
FROM links
WHERE id = ?1
`

func (q *Queries) DeleteLink(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteLink, id)
	return err
}

const deleteReaction = `-- name: DeleteReaction :exec
DELETE
FROM reactions
WHERE id = ?1
`

func (q *Queries) DeleteReaction(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteReaction, id)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE
FROM sessions
WHERE token = ?1
`

func (q *Queries) DeleteSession(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, token)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE
FROM tasks
WHERE id = ?1
`

func (q *Queries) DeleteTask(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTask, id)
	return err
}

const deleteTicket = `-- name: DeleteTicket :exec
DELETE
FROM tickets
WHERE id = ?1
`

func (q *Queries) DeleteTicket(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTicket, id)
	return err
}

const deleteTimeline = `-- name: DeleteTimeline :exec
DELETE
FROM timeline
WHERE id = ?1
`

func (q *Queries) DeleteTimeline(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTimeline, id)
	return err
}

const deleteType = `-- name: DeleteType :exec
DELETE
FROM types
WHERE id = ?1
`

func (q *Queries) DeleteType(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteType, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE
FROM users
WHERE id = ?1
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const deleteWebhook = `-- name: DeleteWebhook :exec
DELETE
FROM webhooks
WHERE id = ?1
`

func (q *Queries) DeleteWebhook(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteWebhook, id)
	return err
}

const findSession = `-- name: FindSession :one

SELECT token, data, expiry
FROM sessions
WHERE token = ?1
`

// ----------------------------------------------------------------
func (q *Queries) FindSession(ctx context.Context, token string) (Session, error) {
	row := q.db.QueryRowContext(ctx, findSession, token)
	var i Session
	err := row.Scan(&i.Token, &i.Data, &i.Expiry)
	return i, err
}

const getComment = `-- name: GetComment :one
SELECT author, created, id, message, ticket, updated
FROM comments
WHERE id = ?1
`

func (q *Queries) GetComment(ctx context.Context, id string) (Comment, error) {
	row := q.db.QueryRowContext(ctx, getComment, id)
	var i Comment
	err := row.Scan(
		&i.Author,
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const getDashboardCounts = `-- name: GetDashboardCounts :many

SELECT id, count
FROM dashboard_counts
`

// ----------------------------------------------------------------
func (q *Queries) GetDashboardCounts(ctx context.Context) ([]DashboardCount, error) {
	rows, err := q.db.QueryContext(ctx, getDashboardCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DashboardCount
	for rows.Next() {
		var i DashboardCount
		if err := rows.Scan(&i.ID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeature = `-- name: GetFeature :one
SELECT created, id, name, updated
FROM features
WHERE id = ?1
`

func (q *Queries) GetFeature(ctx context.Context, id string) (Feature, error) {
	row := q.db.QueryRowContext(ctx, getFeature, id)
	var i Feature
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const getFile = `-- name: GetFile :one
SELECT blob, created, id, name, size, ticket, updated
FROM files
WHERE id = ?1
`

func (q *Queries) GetFile(ctx context.Context, id string) (File, error) {
	row := q.db.QueryRowContext(ctx, getFile, id)
	var i File
	err := row.Scan(
		&i.Blob,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Size,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const getLink = `-- name: GetLink :one
SELECT created, id, name, ticket, updated, url
FROM links
WHERE id = ?1
`

func (q *Queries) GetLink(ctx context.Context, id string) (Link, error) {
	row := q.db.QueryRowContext(ctx, getLink, id)
	var i Link
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Ticket,
		&i.Updated,
		&i.Url,
	)
	return i, err
}

const getReaction = `-- name: GetReaction :one
SELECT "action", actiondata, created, id, name, "trigger", triggerdata, updated
FROM reactions
WHERE id = ?1
`

func (q *Queries) GetReaction(ctx context.Context, id string) (Reaction, error) {
	row := q.db.QueryRowContext(ctx, getReaction, id)
	var i Reaction
	err := row.Scan(
		&i.Action,
		&i.Actiondata,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Trigger,
		&i.Triggerdata,
		&i.Updated,
	)
	return i, err
}

const getSidebar = `-- name: GetSidebar :many
SELECT id, singular, plural, icon, count
FROM sidebar
`

func (q *Queries) GetSidebar(ctx context.Context) ([]Sidebar, error) {
	rows, err := q.db.QueryContext(ctx, getSidebar)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sidebar
	for rows.Next() {
		var i Sidebar
		if err := rows.Scan(
			&i.ID,
			&i.Singular,
			&i.Plural,
			&i.Icon,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTask = `-- name: GetTask :one
SELECT created, id, name, open, owner, ticket, updated
FROM tasks
WHERE id = ?1
`

func (q *Queries) GetTask(ctx context.Context, id string) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i Task
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const getTimeline = `-- name: GetTimeline :one
SELECT created, id, message, ticket, time, updated
FROM timeline
WHERE id = ?1
`

func (q *Queries) GetTimeline(ctx context.Context, id string) (Timeline, error) {
	row := q.db.QueryRowContext(ctx, getTimeline, id)
	var i Timeline
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Time,
		&i.Updated,
	)
	return i, err
}

const getType = `-- name: GetType :one
SELECT created, icon, id, plural, schema, singular, updated
FROM types
WHERE id = ?1
`

func (q *Queries) GetType(ctx context.Context, id string) (Type, error) {
	row := q.db.QueryRowContext(ctx, getType, id)
	var i Type
	err := row.Scan(
		&i.Created,
		&i.Icon,
		&i.ID,
		&i.Plural,
		&i.Schema,
		&i.Singular,
		&i.Updated,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT avatar, created, email, emailvisibility, id, lastloginalertsentat, lastresetsentat, lastverificationsentat, name, passwordhash, tokenkey, updated, username, verified
FROM users
WHERE id = ?1
`

func (q *Queries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.Avatar,
		&i.Created,
		&i.Email,
		&i.Emailvisibility,
		&i.ID,
		&i.Lastloginalertsentat,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Name,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Updated,
		&i.Username,
		&i.Verified,
	)
	return i, err
}

const getWebhook = `-- name: GetWebhook :one
SELECT collection, created, destination, id, name, updated
FROM webhooks
WHERE id = ?1
`

func (q *Queries) GetWebhook(ctx context.Context, id string) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, getWebhook, id)
	var i Webhook
	err := row.Scan(
		&i.Collection,
		&i.Created,
		&i.Destination,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const listComments = `-- name: ListComments :many
SELECT author, created, id, message, ticket, updated
FROM comments
WHERE ticket = ?1 OR ?1 = ''
ORDER BY created DESC
LIMIT ?3 OFFSET ?2
`

type ListCommentsParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) ListComments(ctx context.Context, arg ListCommentsParams) ([]Comment, error) {
	rows, err := q.db.QueryContext(ctx, listComments, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.Author,
			&i.Created,
			&i.ID,
			&i.Message,
			&i.Ticket,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeatures = `-- name: ListFeatures :many
SELECT created, id, name, updated
FROM features
ORDER BY created DESC
`

func (q *Queries) ListFeatures(ctx context.Context) ([]Feature, error) {
	rows, err := q.db.QueryContext(ctx, listFeatures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feature
	for rows.Next() {
		var i Feature
		if err := rows.Scan(
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFiles = `-- name: ListFiles :many
SELECT blob, created, id, name, size, ticket, updated
FROM files
WHERE ticket = ?1 OR ?1 = ''
ORDER BY created DESC
LIMIT ?3 OFFSET ?2
`

type ListFilesParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) ListFiles(ctx context.Context, arg ListFilesParams) ([]File, error) {
	rows, err := q.db.QueryContext(ctx, listFiles, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.Blob,
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Size,
			&i.Ticket,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinks = `-- name: ListLinks :many
SELECT created, id, name, ticket, updated, url
FROM links
WHERE ticket = ?1 OR ?1 = ''
ORDER BY created DESC
LIMIT ?3 OFFSET ?2
`

type ListLinksParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) ListLinks(ctx context.Context, arg ListLinksParams) ([]Link, error) {
	rows, err := q.db.QueryContext(ctx, listLinks, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Link
	for rows.Next() {
		var i Link
		if err := rows.Scan(
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Ticket,
			&i.Updated,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReactions = `-- name: ListReactions :many
SELECT "action", actiondata, created, id, name, "trigger", triggerdata, updated
FROM reactions
ORDER BY created DESC
LIMIT ?2 OFFSET ?1
`

type ListReactionsParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) ListReactions(ctx context.Context, arg ListReactionsParams) ([]Reaction, error) {
	rows, err := q.db.QueryContext(ctx, listReactions, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reaction
	for rows.Next() {
		var i Reaction
		if err := rows.Scan(
			&i.Action,
			&i.Actiondata,
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Trigger,
			&i.Triggerdata,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT created, id, name, open, owner, ticket, updated
FROM tasks
WHERE ticket = ?1 OR ?1 = ''
ORDER BY created DESC
LIMIT ?3 OFFSET ?2
`

type ListTasksParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) ListTasks(ctx context.Context, arg ListTasksParams) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasks, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Open,
			&i.Owner,
			&i.Ticket,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTickets = `-- name: ListTickets :many
SELECT created, description, id, name, open, owner, resolution, schema, state, type, updated
FROM tickets
ORDER BY created DESC
LIMIT ?2 OFFSET ?1
`

type ListTicketsParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) ListTickets(ctx context.Context, arg ListTicketsParams) ([]Ticket, error) {
	rows, err := q.db.QueryContext(ctx, listTickets, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ticket
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.Created,
			&i.Description,
			&i.ID,
			&i.Name,
			&i.Open,
			&i.Owner,
			&i.Resolution,
			&i.Schema,
			&i.State,
			&i.Type,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTimeline = `-- name: ListTimeline :many
SELECT created, id, message, ticket, time, updated
FROM timeline
WHERE ticket = ?1 OR ?1 = ''
ORDER BY created DESC
LIMIT ?3 OFFSET ?2
`

type ListTimelineParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) ListTimeline(ctx context.Context, arg ListTimelineParams) ([]Timeline, error) {
	rows, err := q.db.QueryContext(ctx, listTimeline, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Timeline
	for rows.Next() {
		var i Timeline
		if err := rows.Scan(
			&i.Created,
			&i.ID,
			&i.Message,
			&i.Ticket,
			&i.Time,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTypes = `-- name: ListTypes :many
SELECT created, icon, id, plural, schema, singular, updated
FROM types
ORDER BY created DESC
`

func (q *Queries) ListTypes(ctx context.Context) ([]Type, error) {
	rows, err := q.db.QueryContext(ctx, listTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Type
	for rows.Next() {
		var i Type
		if err := rows.Scan(
			&i.Created,
			&i.Icon,
			&i.ID,
			&i.Plural,
			&i.Schema,
			&i.Singular,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT avatar, created, email, emailvisibility, id, lastloginalertsentat, lastresetsentat, lastverificationsentat, name, passwordhash, tokenkey, updated, username, verified
FROM users
ORDER BY created DESC
LIMIT ?2 OFFSET ?1
`

type ListUsersParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.Avatar,
			&i.Created,
			&i.Email,
			&i.Emailvisibility,
			&i.ID,
			&i.Lastloginalertsentat,
			&i.Lastresetsentat,
			&i.Lastverificationsentat,
			&i.Name,
			&i.Passwordhash,
			&i.Tokenkey,
			&i.Updated,
			&i.Username,
			&i.Verified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooks = `-- name: ListWebhooks :many
SELECT collection, created, destination, id, name, updated
FROM webhooks
ORDER BY created DESC
LIMIT ?2 OFFSET ?1
`

type ListWebhooksParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) ListWebhooks(ctx context.Context, arg ListWebhooksParams) ([]Webhook, error) {
	rows, err := q.db.QueryContext(ctx, listWebhooks, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Webhook
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.Collection,
			&i.Created,
			&i.Destination,
			&i.ID,
			&i.Name,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTickets = `-- name: SearchTickets :many
SELECT id, name, created, description, open, type, state, owner_name, comment_messages, file_names, link_names, link_urls, task_names, timeline_messages
FROM ticket_search
WHERE name LIKE '%' || ?1 || '%'
   OR description LIKE '%' || ?1 || '%'
   OR comment_messages LIKE '%' || ?1 || '%'
   OR file_names LIKE '%' || ?1 || '%'
   OR link_names LIKE '%' || ?1 || '%'
   OR link_urls LIKE '%' || ?1 || '%'
   OR task_names LIKE '%' || ?1 || '%'
   OR timeline_messages LIKE '%' || ?1 || '%'
LIMIT ?3 OFFSET ?2
`

type SearchTicketsParams struct {
	Query  sql.NullString `json:"query"`
	Offset int64          `json:"offset"`
	Limit  int64          `json:"limit"`
}

func (q *Queries) SearchTickets(ctx context.Context, arg SearchTicketsParams) ([]TicketSearch, error) {
	rows, err := q.db.QueryContext(ctx, searchTickets, arg.Query, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TicketSearch
	for rows.Next() {
		var i TicketSearch
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Description,
			&i.Open,
			&i.Type,
			&i.State,
			&i.OwnerName,
			&i.CommentMessages,
			&i.FileNames,
			&i.LinkNames,
			&i.LinkUrls,
			&i.TaskNames,
			&i.TimelineMessages,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ticket = `-- name: Ticket :one
SELECT created, description, id, name, open, owner, resolution, schema, state, type, updated
FROM tickets
WHERE id = ?1
`

func (q *Queries) Ticket(ctx context.Context, id string) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, ticket, id)
	var i Ticket
	err := row.Scan(
		&i.Created,
		&i.Description,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Resolution,
		&i.Schema,
		&i.State,
		&i.Type,
		&i.Updated,
	)
	return i, err
}

const updateComment = `-- name: UpdateComment :exec
UPDATE comments
SET message = ?1
WHERE id = ?2
`

type UpdateCommentParams struct {
	Message string `json:"message"`
	ID      string `json:"id"`
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) error {
	_, err := q.db.ExecContext(ctx, updateComment, arg.Message, arg.ID)
	return err
}

const updateFeature = `-- name: UpdateFeature :exec
UPDATE features
SET name = ?1
WHERE id = ?2
`

type UpdateFeatureParams struct {
	Name string `json:"name"`
	ID   string `json:"id"`
}

func (q *Queries) UpdateFeature(ctx context.Context, arg UpdateFeatureParams) error {
	_, err := q.db.ExecContext(ctx, updateFeature, arg.Name, arg.ID)
	return err
}

const updateFile = `-- name: UpdateFile :exec
UPDATE files
SET name = ?1, blob = ?2, size = ?3
WHERE id = ?4
`

type UpdateFileParams struct {
	Name string  `json:"name"`
	Blob string  `json:"blob"`
	Size float64 `json:"size"`
	ID   string  `json:"id"`
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) error {
	_, err := q.db.ExecContext(ctx, updateFile,
		arg.Name,
		arg.Blob,
		arg.Size,
		arg.ID,
	)
	return err
}

const updateLink = `-- name: UpdateLink :exec
UPDATE links
SET name = ?1, url = ?2
WHERE id = ?3
`

type UpdateLinkParams struct {
	Name string `json:"name"`
	Url  string `json:"url"`
	ID   string `json:"id"`
}

func (q *Queries) UpdateLink(ctx context.Context, arg UpdateLinkParams) error {
	_, err := q.db.ExecContext(ctx, updateLink, arg.Name, arg.Url, arg.ID)
	return err
}

const updateReaction = `-- name: UpdateReaction :exec
UPDATE reactions
SET name = ?1, action = ?2, actiondata = ?3, trigger = ?4, triggerdata = ?5
WHERE id = ?6
`

type UpdateReactionParams struct {
	Name        string      `json:"name"`
	Action      string      `json:"action"`
	Actiondata  interface{} `json:"actiondata"`
	Trigger     string      `json:"trigger"`
	Triggerdata interface{} `json:"triggerdata"`
	ID          string      `json:"id"`
}

func (q *Queries) UpdateReaction(ctx context.Context, arg UpdateReactionParams) error {
	_, err := q.db.ExecContext(ctx, updateReaction,
		arg.Name,
		arg.Action,
		arg.Actiondata,
		arg.Trigger,
		arg.Triggerdata,
		arg.ID,
	)
	return err
}

const updateTask = `-- name: UpdateTask :exec
UPDATE tasks
SET name = ?1, open = ?2, owner = ?3
WHERE id = ?4
`

type UpdateTaskParams struct {
	Name  string `json:"name"`
	Open  bool   `json:"open"`
	Owner string `json:"owner"`
	ID    string `json:"id"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.db.ExecContext(ctx, updateTask,
		arg.Name,
		arg.Open,
		arg.Owner,
		arg.ID,
	)
	return err
}

const updateTicket = `-- name: UpdateTicket :exec
UPDATE tickets
SET name = ?1,
    description = ?2,
    open = ?3,
    owner = ?4,
    resolution = ?5,
    schema = ?6,
    state = ?7,
    type = ?8
WHERE id = ?9
`

type UpdateTicketParams struct {
	Name        string      `json:"name"`
	Description string      `json:"description"`
	Open        bool        `json:"open"`
	Owner       string      `json:"owner"`
	Resolution  string      `json:"resolution"`
	Schema      interface{} `json:"schema"`
	State       interface{} `json:"state"`
	Type        string      `json:"type"`
	ID          string      `json:"id"`
}

func (q *Queries) UpdateTicket(ctx context.Context, arg UpdateTicketParams) error {
	_, err := q.db.ExecContext(ctx, updateTicket,
		arg.Name,
		arg.Description,
		arg.Open,
		arg.Owner,
		arg.Resolution,
		arg.Schema,
		arg.State,
		arg.Type,
		arg.ID,
	)
	return err
}

const updateTimeline = `-- name: UpdateTimeline :exec
UPDATE timeline
SET message = ?1, time = ?2
WHERE id = ?3
`

type UpdateTimelineParams struct {
	Message string `json:"message"`
	Time    string `json:"time"`
	ID      string `json:"id"`
}

func (q *Queries) UpdateTimeline(ctx context.Context, arg UpdateTimelineParams) error {
	_, err := q.db.ExecContext(ctx, updateTimeline, arg.Message, arg.Time, arg.ID)
	return err
}

const updateType = `-- name: UpdateType :exec
UPDATE types
SET singular = ?1, plural = ?2, icon = ?3, schema = ?4
WHERE id = ?5
`

type UpdateTypeParams struct {
	Singular string      `json:"singular"`
	Plural   string      `json:"plural"`
	Icon     string      `json:"icon"`
	Schema   interface{} `json:"schema"`
	ID       string      `json:"id"`
}

func (q *Queries) UpdateType(ctx context.Context, arg UpdateTypeParams) error {
	_, err := q.db.ExecContext(ctx, updateType,
		arg.Singular,
		arg.Plural,
		arg.Icon,
		arg.Schema,
		arg.ID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET name = ?1, email = ?2, username = ?3, passwordHash = ?4, tokenKey = ?5
WHERE id = ?6
`

type UpdateUserParams struct {
	Name         string `json:"name"`
	Email        string `json:"email"`
	Username     string `json:"username"`
	PasswordHash string `json:"passwordHash"`
	TokenKey     string `json:"tokenKey"`
	ID           string `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Name,
		arg.Email,
		arg.Username,
		arg.PasswordHash,
		arg.TokenKey,
		arg.ID,
	)
	return err
}

const updateWebhook = `-- name: UpdateWebhook :exec
UPDATE webhooks
SET name = ?1, collection = ?2, destination = ?3
WHERE id = ?4
`

type UpdateWebhookParams struct {
	Name        string `json:"name"`
	Collection  string `json:"collection"`
	Destination string `json:"destination"`
	ID          string `json:"id"`
}

func (q *Queries) UpdateWebhook(ctx context.Context, arg UpdateWebhookParams) error {
	_, err := q.db.ExecContext(ctx, updateWebhook,
		arg.Name,
		arg.Collection,
		arg.Destination,
		arg.ID,
	)
	return err
}
