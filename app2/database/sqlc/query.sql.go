// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const commitSession = `-- name: CommitSession :exec
INSERT OR
REPLACE
INTO sessions (token, data, expiry)
VALUES (?1, ?2, ?3)
`

type CommitSessionParams struct {
	Token  string `json:"token"`
	Data   []byte `json:"data"`
	Expiry int64  `json:"expiry"`
}

func (q *Queries) CommitSession(ctx context.Context, arg CommitSessionParams) error {
	_, err := q.db.ExecContext(ctx, commitSession, arg.Token, arg.Data, arg.Expiry)
	return err
}

const createComment = `-- name: CreateComment :one

INSERT INTO comments (author, message, ticket)
VALUES (?1, ?2, ?3)
RETURNING author, created, id, message, ticket, updated
`

type CreateCommentParams struct {
	Author  string `json:"author"`
	Message string `json:"message"`
	Ticket  string `json:"ticket"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, createComment, arg.Author, arg.Message, arg.Ticket)
	var i Comment
	err := row.Scan(
		&i.Author,
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const createFeature = `-- name: CreateFeature :one

INSERT INTO features (name)
VALUES (?1)
RETURNING created, id, name, updated
`

// ----------------------------------------------------------------
func (q *Queries) CreateFeature(ctx context.Context, name string) (Feature, error) {
	row := q.db.QueryRowContext(ctx, createFeature, name)
	var i Feature
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const createFile = `-- name: CreateFile :one

INSERT INTO files (name, blob, size, ticket)
VALUES (?1, ?2, ?3, ?4)
RETURNING blob, created, id, name, size, ticket, updated
`

type CreateFileParams struct {
	Name   string `json:"name"`
	Blob   string `json:"blob"`
	Size   int64  `json:"size"`
	Ticket string `json:"ticket"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, createFile,
		arg.Name,
		arg.Blob,
		arg.Size,
		arg.Ticket,
	)
	var i File
	err := row.Scan(
		&i.Blob,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Size,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const createLink = `-- name: CreateLink :one

INSERT INTO links (name, url, ticket)
VALUES (?1, ?2, ?3)
RETURNING created, id, name, ticket, updated, url
`

type CreateLinkParams struct {
	Name   string `json:"name"`
	Url    string `json:"url"`
	Ticket string `json:"ticket"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateLink(ctx context.Context, arg CreateLinkParams) (Link, error) {
	row := q.db.QueryRowContext(ctx, createLink, arg.Name, arg.Url, arg.Ticket)
	var i Link
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Ticket,
		&i.Updated,
		&i.Url,
	)
	return i, err
}

const createReaction = `-- name: CreateReaction :one

INSERT INTO reactions (name, action, actiondata, trigger, triggerdata)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING "action", actiondata, created, id, name, "trigger", triggerdata, updated
`

type CreateReactionParams struct {
	Name        string      `json:"name"`
	Action      string      `json:"action"`
	Actiondata  interface{} `json:"actiondata"`
	Trigger     string      `json:"trigger"`
	Triggerdata interface{} `json:"triggerdata"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateReaction(ctx context.Context, arg CreateReactionParams) (Reaction, error) {
	row := q.db.QueryRowContext(ctx, createReaction,
		arg.Name,
		arg.Action,
		arg.Actiondata,
		arg.Trigger,
		arg.Triggerdata,
	)
	var i Reaction
	err := row.Scan(
		&i.Action,
		&i.Actiondata,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Trigger,
		&i.Triggerdata,
		&i.Updated,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one

INSERT INTO tasks (name, open, owner, ticket)
VALUES (?1, ?2, ?3, ?4)
RETURNING created, id, name, open, owner, ticket, updated
`

type CreateTaskParams struct {
	Name   string `json:"name"`
	Open   bool   `json:"open"`
	Owner  string `json:"owner"`
	Ticket string `json:"ticket"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, createTask,
		arg.Name,
		arg.Open,
		arg.Owner,
		arg.Ticket,
	)
	var i Task
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const createTicket = `-- name: CreateTicket :one
INSERT INTO tickets (name, description, open, owner, resolution, schema, state, type)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)
RETURNING created, description, id, name, open, owner, resolution, schema, state, type, updated
`

type CreateTicketParams struct {
	Name        string      `json:"name"`
	Description string      `json:"description"`
	Open        bool        `json:"open"`
	Owner       string      `json:"owner"`
	Resolution  string      `json:"resolution"`
	Schema      interface{} `json:"schema"`
	State       interface{} `json:"state"`
	Type        string      `json:"type"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, createTicket,
		arg.Name,
		arg.Description,
		arg.Open,
		arg.Owner,
		arg.Resolution,
		arg.Schema,
		arg.State,
		arg.Type,
	)
	var i Ticket
	err := row.Scan(
		&i.Created,
		&i.Description,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Resolution,
		&i.Schema,
		&i.State,
		&i.Type,
		&i.Updated,
	)
	return i, err
}

const createTimeline = `-- name: CreateTimeline :one

INSERT INTO timeline (message, ticket, time)
VALUES (?1, ?2, ?3)
RETURNING created, id, message, ticket, time, updated
`

type CreateTimelineParams struct {
	Message string `json:"message"`
	Ticket  string `json:"ticket"`
	Time    string `json:"time"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateTimeline(ctx context.Context, arg CreateTimelineParams) (Timeline, error) {
	row := q.db.QueryRowContext(ctx, createTimeline, arg.Message, arg.Ticket, arg.Time)
	var i Timeline
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Time,
		&i.Updated,
	)
	return i, err
}

const createType = `-- name: CreateType :one

INSERT INTO types (singular, plural, icon, schema)
VALUES (?1, ?2, ?3, ?4)
RETURNING created, icon, id, plural, schema, singular, updated
`

type CreateTypeParams struct {
	Singular string      `json:"singular"`
	Plural   string      `json:"plural"`
	Icon     string      `json:"icon"`
	Schema   interface{} `json:"schema"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateType(ctx context.Context, arg CreateTypeParams) (Type, error) {
	row := q.db.QueryRowContext(ctx, createType,
		arg.Singular,
		arg.Plural,
		arg.Icon,
		arg.Schema,
	)
	var i Type
	err := row.Scan(
		&i.Created,
		&i.Icon,
		&i.ID,
		&i.Plural,
		&i.Schema,
		&i.Singular,
		&i.Updated,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (name, email, username, passwordHash, tokenKey)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING avatar, created, email, emailvisibility, id, lastloginalertsentat, lastresetsentat, lastverificationsentat, name, passwordhash, tokenkey, updated, username, verified
`

type CreateUserParams struct {
	Name         string `json:"name"`
	Email        string `json:"email"`
	Username     string `json:"username"`
	PasswordHash string `json:"passwordHash"`
	TokenKey     string `json:"tokenKey"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Name,
		arg.Email,
		arg.Username,
		arg.PasswordHash,
		arg.TokenKey,
	)
	var i User
	err := row.Scan(
		&i.Avatar,
		&i.Created,
		&i.Email,
		&i.Emailvisibility,
		&i.ID,
		&i.Lastloginalertsentat,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Name,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Updated,
		&i.Username,
		&i.Verified,
	)
	return i, err
}

const createWebhook = `-- name: CreateWebhook :one

INSERT INTO webhooks (name, collection, destination)
VALUES (?1, ?2, ?3)
RETURNING collection, created, destination, id, name, updated
`

type CreateWebhookParams struct {
	Name        string `json:"name"`
	Collection  string `json:"collection"`
	Destination string `json:"destination"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateWebhook(ctx context.Context, arg CreateWebhookParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, createWebhook, arg.Name, arg.Collection, arg.Destination)
	var i Webhook
	err := row.Scan(
		&i.Collection,
		&i.Created,
		&i.Destination,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE
FROM comments
WHERE id = ?1
`

func (q *Queries) DeleteComment(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteComment, id)
	return err
}

const deleteFeature = `-- name: DeleteFeature :exec
DELETE
FROM features
WHERE id = ?1
`

func (q *Queries) DeleteFeature(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteFeature, id)
	return err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE
FROM files
WHERE id = ?1
`

func (q *Queries) DeleteFile(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteFile, id)
	return err
}

const deleteLink = `-- name: DeleteLink :exec
DELETE
FROM links
WHERE id = ?1
`

func (q *Queries) DeleteLink(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteLink, id)
	return err
}

const deleteReaction = `-- name: DeleteReaction :exec
DELETE
FROM reactions
WHERE id = ?1
`

func (q *Queries) DeleteReaction(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteReaction, id)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE
FROM sessions
WHERE token = ?1
`

func (q *Queries) DeleteSession(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, token)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE
FROM tasks
WHERE id = ?1
`

func (q *Queries) DeleteTask(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTask, id)
	return err
}

const deleteTicket = `-- name: DeleteTicket :exec
DELETE
FROM tickets
WHERE id = ?1
`

func (q *Queries) DeleteTicket(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTicket, id)
	return err
}

const deleteTimeline = `-- name: DeleteTimeline :exec
DELETE
FROM timeline
WHERE id = ?1
`

func (q *Queries) DeleteTimeline(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTimeline, id)
	return err
}

const deleteType = `-- name: DeleteType :exec
DELETE
FROM types
WHERE id = ?1
`

func (q *Queries) DeleteType(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteType, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE
FROM users
WHERE id = ?1
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const deleteWebhook = `-- name: DeleteWebhook :exec
DELETE
FROM webhooks
WHERE id = ?1
`

func (q *Queries) DeleteWebhook(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteWebhook, id)
	return err
}

const findSession = `-- name: FindSession :one

SELECT token, data, expiry
FROM sessions
WHERE token = ?1
`

// ----------------------------------------------------------------
func (q *Queries) FindSession(ctx context.Context, token string) (Session, error) {
	row := q.db.QueryRowContext(ctx, findSession, token)
	var i Session
	err := row.Scan(&i.Token, &i.Data, &i.Expiry)
	return i, err
}

const getComment = `-- name: GetComment :one
SELECT author, created, id, message, ticket, updated
FROM comments
WHERE id = ?1
`

func (q *Queries) GetComment(ctx context.Context, id string) (Comment, error) {
	row := q.db.QueryRowContext(ctx, getComment, id)
	var i Comment
	err := row.Scan(
		&i.Author,
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const getDashboardCounts = `-- name: GetDashboardCounts :many

SELECT id, count
FROM dashboard_counts
`

// ----------------------------------------------------------------
func (q *Queries) GetDashboardCounts(ctx context.Context) ([]DashboardCount, error) {
	rows, err := q.db.QueryContext(ctx, getDashboardCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DashboardCount
	for rows.Next() {
		var i DashboardCount
		if err := rows.Scan(&i.ID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeature = `-- name: GetFeature :one
SELECT created, id, name, updated
FROM features
WHERE id = ?1
`

func (q *Queries) GetFeature(ctx context.Context, id string) (Feature, error) {
	row := q.db.QueryRowContext(ctx, getFeature, id)
	var i Feature
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const getFile = `-- name: GetFile :one
SELECT blob, created, id, name, size, ticket, updated
FROM files
WHERE id = ?1
`

func (q *Queries) GetFile(ctx context.Context, id string) (File, error) {
	row := q.db.QueryRowContext(ctx, getFile, id)
	var i File
	err := row.Scan(
		&i.Blob,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Size,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const getLink = `-- name: GetLink :one
SELECT created, id, name, ticket, updated, url
FROM links
WHERE id = ?1
`

func (q *Queries) GetLink(ctx context.Context, id string) (Link, error) {
	row := q.db.QueryRowContext(ctx, getLink, id)
	var i Link
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Ticket,
		&i.Updated,
		&i.Url,
	)
	return i, err
}

const getReaction = `-- name: GetReaction :one
SELECT "action", actiondata, created, id, name, "trigger", triggerdata, updated
FROM reactions
WHERE id = ?1
`

func (q *Queries) GetReaction(ctx context.Context, id string) (Reaction, error) {
	row := q.db.QueryRowContext(ctx, getReaction, id)
	var i Reaction
	err := row.Scan(
		&i.Action,
		&i.Actiondata,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Trigger,
		&i.Triggerdata,
		&i.Updated,
	)
	return i, err
}

const getSidebar = `-- name: GetSidebar :many
SELECT id, singular, plural, icon, count
FROM sidebar
`

func (q *Queries) GetSidebar(ctx context.Context) ([]Sidebar, error) {
	rows, err := q.db.QueryContext(ctx, getSidebar)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sidebar
	for rows.Next() {
		var i Sidebar
		if err := rows.Scan(
			&i.ID,
			&i.Singular,
			&i.Plural,
			&i.Icon,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTask = `-- name: GetTask :one
SELECT created, id, name, open, owner, ticket, updated
FROM tasks
WHERE id = ?1
`

func (q *Queries) GetTask(ctx context.Context, id string) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i Task
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const getTimeline = `-- name: GetTimeline :one
SELECT created, id, message, ticket, time, updated
FROM timeline
WHERE id = ?1
`

func (q *Queries) GetTimeline(ctx context.Context, id string) (Timeline, error) {
	row := q.db.QueryRowContext(ctx, getTimeline, id)
	var i Timeline
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Time,
		&i.Updated,
	)
	return i, err
}

const getType = `-- name: GetType :one
SELECT created, icon, id, plural, schema, singular, updated
FROM types
WHERE id = ?1
`

func (q *Queries) GetType(ctx context.Context, id string) (Type, error) {
	row := q.db.QueryRowContext(ctx, getType, id)
	var i Type
	err := row.Scan(
		&i.Created,
		&i.Icon,
		&i.ID,
		&i.Plural,
		&i.Schema,
		&i.Singular,
		&i.Updated,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT avatar, created, email, emailvisibility, id, lastloginalertsentat, lastresetsentat, lastverificationsentat, name, passwordhash, tokenkey, updated, username, verified
FROM users
WHERE id = ?1
`

func (q *Queries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.Avatar,
		&i.Created,
		&i.Email,
		&i.Emailvisibility,
		&i.ID,
		&i.Lastloginalertsentat,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Name,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Updated,
		&i.Username,
		&i.Verified,
	)
	return i, err
}

const getWebhook = `-- name: GetWebhook :one
SELECT collection, created, destination, id, name, updated
FROM webhooks
WHERE id = ?1
`

func (q *Queries) GetWebhook(ctx context.Context, id string) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, getWebhook, id)
	var i Webhook
	err := row.Scan(
		&i.Collection,
		&i.Created,
		&i.Destination,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const listComments = `-- name: ListComments :many
SELECT author, created, id, message, ticket, updated
FROM comments
WHERE ticket = ?1 OR ?1 = ''
ORDER BY created DESC
LIMIT ?3 OFFSET ?2
`

type ListCommentsParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) ListComments(ctx context.Context, arg ListCommentsParams) ([]Comment, error) {
	rows, err := q.db.QueryContext(ctx, listComments, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.Author,
			&i.Created,
			&i.ID,
			&i.Message,
			&i.Ticket,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeatures = `-- name: ListFeatures :many
SELECT created, id, name, updated
FROM features
ORDER BY created DESC
`

func (q *Queries) ListFeatures(ctx context.Context) ([]Feature, error) {
	rows, err := q.db.QueryContext(ctx, listFeatures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feature
	for rows.Next() {
		var i Feature
		if err := rows.Scan(
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFiles = `-- name: ListFiles :many
SELECT blob, created, id, name, size, ticket, updated
FROM files
WHERE ticket = ?1 OR ?1 = ''
ORDER BY created DESC
LIMIT ?3 OFFSET ?2
`

type ListFilesParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) ListFiles(ctx context.Context, arg ListFilesParams) ([]File, error) {
	rows, err := q.db.QueryContext(ctx, listFiles, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.Blob,
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Size,
			&i.Ticket,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinks = `-- name: ListLinks :many
SELECT created, id, name, ticket, updated, url
FROM links
WHERE ticket = ?1 OR ?1 = ''
ORDER BY created DESC
LIMIT ?3 OFFSET ?2
`

type ListLinksParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) ListLinks(ctx context.Context, arg ListLinksParams) ([]Link, error) {
	rows, err := q.db.QueryContext(ctx, listLinks, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Link
	for rows.Next() {
		var i Link
		if err := rows.Scan(
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Ticket,
			&i.Updated,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReactions = `-- name: ListReactions :many
SELECT "action", actiondata, created, id, name, "trigger", triggerdata, updated
FROM reactions
ORDER BY created DESC
LIMIT ?2 OFFSET ?1
`

type ListReactionsParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) ListReactions(ctx context.Context, arg ListReactionsParams) ([]Reaction, error) {
	rows, err := q.db.QueryContext(ctx, listReactions, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reaction
	for rows.Next() {
		var i Reaction
		if err := rows.Scan(
			&i.Action,
			&i.Actiondata,
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Trigger,
			&i.Triggerdata,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSearchTickets = `-- name: ListSearchTickets :many
SELECT 
    id, 
    name, 
    created,
    description,
    open,
    type,
    state,
    owner_name
FROM ticket_search
LIMIT ?2 OFFSET ?1
`

type ListSearchTicketsParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListSearchTicketsRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Created     string         `json:"created"`
	Description string         `json:"description"`
	Open        bool           `json:"open"`
	Type        string         `json:"type"`
	State       interface{}    `json:"state"`
	OwnerName   sql.NullString `json:"owner_name"`
}

func (q *Queries) ListSearchTickets(ctx context.Context, arg ListSearchTicketsParams) ([]ListSearchTicketsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSearchTickets, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSearchTicketsRow
	for rows.Next() {
		var i ListSearchTicketsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Description,
			&i.Open,
			&i.Type,
			&i.State,
			&i.OwnerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT created, id, name, open, owner, ticket, updated
FROM tasks
WHERE ticket = ?1 OR ?1 = ''
ORDER BY created DESC
LIMIT ?3 OFFSET ?2
`

type ListTasksParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) ListTasks(ctx context.Context, arg ListTasksParams) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasks, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Open,
			&i.Owner,
			&i.Ticket,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTickets = `-- name: ListTickets :many
SELECT created, description, id, name, open, owner, resolution, schema, state, type, updated
FROM tickets
ORDER BY created DESC
LIMIT ?2 OFFSET ?1
`

type ListTicketsParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) ListTickets(ctx context.Context, arg ListTicketsParams) ([]Ticket, error) {
	rows, err := q.db.QueryContext(ctx, listTickets, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ticket
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.Created,
			&i.Description,
			&i.ID,
			&i.Name,
			&i.Open,
			&i.Owner,
			&i.Resolution,
			&i.Schema,
			&i.State,
			&i.Type,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTimeline = `-- name: ListTimeline :many
SELECT created, id, message, ticket, time, updated
FROM timeline
WHERE ticket = ?1 OR ?1 = ''
ORDER BY created DESC
LIMIT ?3 OFFSET ?2
`

type ListTimelineParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) ListTimeline(ctx context.Context, arg ListTimelineParams) ([]Timeline, error) {
	rows, err := q.db.QueryContext(ctx, listTimeline, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Timeline
	for rows.Next() {
		var i Timeline
		if err := rows.Scan(
			&i.Created,
			&i.ID,
			&i.Message,
			&i.Ticket,
			&i.Time,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTypes = `-- name: ListTypes :many
SELECT created, icon, id, plural, schema, singular, updated
FROM types
ORDER BY created DESC
`

func (q *Queries) ListTypes(ctx context.Context) ([]Type, error) {
	rows, err := q.db.QueryContext(ctx, listTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Type
	for rows.Next() {
		var i Type
		if err := rows.Scan(
			&i.Created,
			&i.Icon,
			&i.ID,
			&i.Plural,
			&i.Schema,
			&i.Singular,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT avatar, created, email, emailvisibility, id, lastloginalertsentat, lastresetsentat, lastverificationsentat, name, passwordhash, tokenkey, updated, username, verified
FROM users
ORDER BY created DESC
LIMIT ?2 OFFSET ?1
`

type ListUsersParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.Avatar,
			&i.Created,
			&i.Email,
			&i.Emailvisibility,
			&i.ID,
			&i.Lastloginalertsentat,
			&i.Lastresetsentat,
			&i.Lastverificationsentat,
			&i.Name,
			&i.Passwordhash,
			&i.Tokenkey,
			&i.Updated,
			&i.Username,
			&i.Verified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooks = `-- name: ListWebhooks :many
SELECT collection, created, destination, id, name, updated
FROM webhooks
ORDER BY created DESC
LIMIT ?2 OFFSET ?1
`

type ListWebhooksParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) ListWebhooks(ctx context.Context, arg ListWebhooksParams) ([]Webhook, error) {
	rows, err := q.db.QueryContext(ctx, listWebhooks, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Webhook
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.Collection,
			&i.Created,
			&i.Destination,
			&i.ID,
			&i.Name,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTickets = `-- name: SearchTickets :many
SELECT 
    id, 
    name, 
    created,
    description,
    open,
    type,
    state,
    owner_name
FROM ticket_search
WHERE name LIKE '%' || ?1 || '%'
   OR description LIKE '%' || ?1 || '%'
   OR comment_messages LIKE '%' || ?1 || '%'
   OR file_names LIKE '%' || ?1 || '%'
   OR link_names LIKE '%' || ?1 || '%'
   OR link_urls LIKE '%' || ?1 || '%'
   OR task_names LIKE '%' || ?1 || '%'
   OR timeline_messages LIKE '%' || ?1 || '%'
LIMIT ?3 OFFSET ?2
`

type SearchTicketsParams struct {
	Query  sql.NullString `json:"query"`
	Offset int64          `json:"offset"`
	Limit  int64          `json:"limit"`
}

type SearchTicketsRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Created     string         `json:"created"`
	Description string         `json:"description"`
	Open        bool           `json:"open"`
	Type        string         `json:"type"`
	State       interface{}    `json:"state"`
	OwnerName   sql.NullString `json:"owner_name"`
}

func (q *Queries) SearchTickets(ctx context.Context, arg SearchTicketsParams) ([]SearchTicketsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchTickets, arg.Query, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchTicketsRow
	for rows.Next() {
		var i SearchTicketsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Description,
			&i.Open,
			&i.Type,
			&i.State,
			&i.OwnerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ticket = `-- name: Ticket :one
SELECT created, description, id, name, open, owner, resolution, schema, state, type, updated
FROM tickets
WHERE id = ?1
`

func (q *Queries) Ticket(ctx context.Context, id string) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, ticket, id)
	var i Ticket
	err := row.Scan(
		&i.Created,
		&i.Description,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Resolution,
		&i.Schema,
		&i.State,
		&i.Type,
		&i.Updated,
	)
	return i, err
}

const updateComment = `-- name: UpdateComment :one
UPDATE comments
SET message = coalesce(?1, message)
WHERE id = ?2
RETURNING author, created, id, message, ticket, updated
`

type UpdateCommentParams struct {
	Message sql.NullString `json:"message"`
	ID      string         `json:"id"`
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, updateComment, arg.Message, arg.ID)
	var i Comment
	err := row.Scan(
		&i.Author,
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const updateFeature = `-- name: UpdateFeature :one
UPDATE features
SET name = coalesce(?1, name)
WHERE id = ?2
RETURNING created, id, name, updated
`

type UpdateFeatureParams struct {
	Name sql.NullString `json:"name"`
	ID   string         `json:"id"`
}

func (q *Queries) UpdateFeature(ctx context.Context, arg UpdateFeatureParams) (Feature, error) {
	row := q.db.QueryRowContext(ctx, updateFeature, arg.Name, arg.ID)
	var i Feature
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const updateFile = `-- name: UpdateFile :one
UPDATE files
SET 
    name = coalesce(?1, name), 
    blob = coalesce(?2, blob), 
    size = coalesce(?3, size)
WHERE id = ?4
RETURNING blob, created, id, name, size, ticket, updated
`

type UpdateFileParams struct {
	Name sql.NullString `json:"name"`
	Blob sql.NullString `json:"blob"`
	Size sql.NullInt64  `json:"size"`
	ID   string         `json:"id"`
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, updateFile,
		arg.Name,
		arg.Blob,
		arg.Size,
		arg.ID,
	)
	var i File
	err := row.Scan(
		&i.Blob,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Size,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const updateLink = `-- name: UpdateLink :one
UPDATE links
SET 
    name = coalesce(?1, name), 
    url = coalesce(?2, url)
WHERE id = ?3
RETURNING created, id, name, ticket, updated, url
`

type UpdateLinkParams struct {
	Name sql.NullString `json:"name"`
	Url  sql.NullString `json:"url"`
	ID   string         `json:"id"`
}

func (q *Queries) UpdateLink(ctx context.Context, arg UpdateLinkParams) (Link, error) {
	row := q.db.QueryRowContext(ctx, updateLink, arg.Name, arg.Url, arg.ID)
	var i Link
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Ticket,
		&i.Updated,
		&i.Url,
	)
	return i, err
}

const updateReaction = `-- name: UpdateReaction :one
UPDATE reactions
SET 
    name = coalesce(?1, name), 
    action = coalesce(?2, action), 
    actiondata = coalesce(?3, actiondata), 
    trigger = coalesce(?4, trigger), 
    triggerdata = coalesce(?5, triggerdata)
WHERE id = ?6
RETURNING "action", actiondata, created, id, name, "trigger", triggerdata, updated
`

type UpdateReactionParams struct {
	Name        sql.NullString `json:"name"`
	Action      sql.NullString `json:"action"`
	Actiondata  interface{}    `json:"actiondata"`
	Trigger     sql.NullString `json:"trigger"`
	Triggerdata interface{}    `json:"triggerdata"`
	ID          string         `json:"id"`
}

func (q *Queries) UpdateReaction(ctx context.Context, arg UpdateReactionParams) (Reaction, error) {
	row := q.db.QueryRowContext(ctx, updateReaction,
		arg.Name,
		arg.Action,
		arg.Actiondata,
		arg.Trigger,
		arg.Triggerdata,
		arg.ID,
	)
	var i Reaction
	err := row.Scan(
		&i.Action,
		&i.Actiondata,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Trigger,
		&i.Triggerdata,
		&i.Updated,
	)
	return i, err
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks
SET 
    name = coalesce(?1, name), 
    open = coalesce(?2, open), 
    owner = coalesce(?3, owner)
WHERE id = ?4
RETURNING created, id, name, open, owner, ticket, updated
`

type UpdateTaskParams struct {
	Name  sql.NullString `json:"name"`
	Open  sql.NullBool   `json:"open"`
	Owner sql.NullString `json:"owner"`
	ID    string         `json:"id"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, updateTask,
		arg.Name,
		arg.Open,
		arg.Owner,
		arg.ID,
	)
	var i Task
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const updateTicket = `-- name: UpdateTicket :one
UPDATE tickets
SET name = coalesce(?1, name),
    description = coalesce(?2, description),
    open = coalesce(?3, open),
    owner = coalesce(?4, owner),
    resolution = coalesce(?5, resolution),
    schema = coalesce(?6, schema),
    state = coalesce(?7, state),
    type = coalesce(?8, type)
WHERE id = ?9
RETURNING created, description, id, name, open, owner, resolution, schema, state, type, updated
`

type UpdateTicketParams struct {
	Name        sql.NullString `json:"name"`
	Description sql.NullString `json:"description"`
	Open        sql.NullBool   `json:"open"`
	Owner       sql.NullString `json:"owner"`
	Resolution  sql.NullString `json:"resolution"`
	Schema      interface{}    `json:"schema"`
	State       interface{}    `json:"state"`
	Type        sql.NullString `json:"type"`
	ID          string         `json:"id"`
}

func (q *Queries) UpdateTicket(ctx context.Context, arg UpdateTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, updateTicket,
		arg.Name,
		arg.Description,
		arg.Open,
		arg.Owner,
		arg.Resolution,
		arg.Schema,
		arg.State,
		arg.Type,
		arg.ID,
	)
	var i Ticket
	err := row.Scan(
		&i.Created,
		&i.Description,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Resolution,
		&i.Schema,
		&i.State,
		&i.Type,
		&i.Updated,
	)
	return i, err
}

const updateTimeline = `-- name: UpdateTimeline :one
UPDATE timeline
SET 
    message = coalesce(?1, message), 
    time = coalesce(?2, time)
WHERE id = ?3
RETURNING created, id, message, ticket, time, updated
`

type UpdateTimelineParams struct {
	Message sql.NullString `json:"message"`
	Time    sql.NullString `json:"time"`
	ID      string         `json:"id"`
}

func (q *Queries) UpdateTimeline(ctx context.Context, arg UpdateTimelineParams) (Timeline, error) {
	row := q.db.QueryRowContext(ctx, updateTimeline, arg.Message, arg.Time, arg.ID)
	var i Timeline
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Time,
		&i.Updated,
	)
	return i, err
}

const updateType = `-- name: UpdateType :one
UPDATE types
SET 
    singular = coalesce(?1, singular), 
    plural = coalesce(?2, plural), 
    icon = coalesce(?3, icon), 
    schema = coalesce(?4, schema)
WHERE id = ?5
RETURNING created, icon, id, plural, schema, singular, updated
`

type UpdateTypeParams struct {
	Singular sql.NullString `json:"singular"`
	Plural   sql.NullString `json:"plural"`
	Icon     sql.NullString `json:"icon"`
	Schema   interface{}    `json:"schema"`
	ID       string         `json:"id"`
}

func (q *Queries) UpdateType(ctx context.Context, arg UpdateTypeParams) (Type, error) {
	row := q.db.QueryRowContext(ctx, updateType,
		arg.Singular,
		arg.Plural,
		arg.Icon,
		arg.Schema,
		arg.ID,
	)
	var i Type
	err := row.Scan(
		&i.Created,
		&i.Icon,
		&i.ID,
		&i.Plural,
		&i.Schema,
		&i.Singular,
		&i.Updated,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET 
    name = coalesce(?1, name), 
    email = coalesce(?2, email), 
    username = coalesce(?3, username), 
    passwordHash = coalesce(?4, passwordHash), 
    tokenKey = coalesce(?5, tokenKey)
WHERE id = ?6
RETURNING avatar, created, email, emailvisibility, id, lastloginalertsentat, lastresetsentat, lastverificationsentat, name, passwordhash, tokenkey, updated, username, verified
`

type UpdateUserParams struct {
	Name         sql.NullString `json:"name"`
	Email        sql.NullString `json:"email"`
	Username     sql.NullString `json:"username"`
	PasswordHash sql.NullString `json:"passwordHash"`
	TokenKey     sql.NullString `json:"tokenKey"`
	ID           string         `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Name,
		arg.Email,
		arg.Username,
		arg.PasswordHash,
		arg.TokenKey,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.Avatar,
		&i.Created,
		&i.Email,
		&i.Emailvisibility,
		&i.ID,
		&i.Lastloginalertsentat,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Name,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Updated,
		&i.Username,
		&i.Verified,
	)
	return i, err
}

const updateWebhook = `-- name: UpdateWebhook :one
UPDATE webhooks
SET 
    name = coalesce(?1, name), 
    collection = coalesce(?2, collection), 
    destination = coalesce(?3, destination)
WHERE id = ?4
RETURNING collection, created, destination, id, name, updated
`

type UpdateWebhookParams struct {
	Name        sql.NullString `json:"name"`
	Collection  sql.NullString `json:"collection"`
	Destination sql.NullString `json:"destination"`
	ID          string         `json:"id"`
}

func (q *Queries) UpdateWebhook(ctx context.Context, arg UpdateWebhookParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, updateWebhook,
		arg.Name,
		arg.Collection,
		arg.Destination,
		arg.ID,
	)
	var i Webhook
	err := row.Scan(
		&i.Collection,
		&i.Created,
		&i.Destination,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}
