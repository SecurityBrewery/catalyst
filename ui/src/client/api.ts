/* tslint:disable */
/* eslint-disable */
/**
 * 
 * API for the catalyst incident response platform.
 *
 * The version of the OpenAPI document: 
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Artifact
 */
export interface Artifact {
    /**
     * 
     * @type {{ [key: string]: Enrichment; }}
     * @memberof Artifact
     */
    'enrichments'?: { [key: string]: Enrichment; };
    /**
     * 
     * @type {string}
     * @memberof Artifact
     */
    'kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof Artifact
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Artifact
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Artifact
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ArtifactOrigin
 */
export interface ArtifactOrigin {
    /**
     * 
     * @type {string}
     * @memberof ArtifactOrigin
     */
    'artifact': string;
    /**
     * 
     * @type {number}
     * @memberof ArtifactOrigin
     */
    'ticket_id': number;
}
/**
 * 
 * @export
 * @interface Automation
 */
export interface Automation {
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    'schema'?: string;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    'script': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Automation
     */
    'type': Array<AutomationTypeEnum>;
}

export const AutomationTypeEnum = {
    Artifact: 'artifact',
    Playbook: 'playbook',
    Global: 'global'
} as const;

export type AutomationTypeEnum = typeof AutomationTypeEnum[keyof typeof AutomationTypeEnum];

/**
 * 
 * @export
 * @interface AutomationForm
 */
export interface AutomationForm {
    /**
     * 
     * @type {string}
     * @memberof AutomationForm
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AutomationForm
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof AutomationForm
     */
    'schema'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutomationForm
     */
    'script': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutomationForm
     */
    'type': Array<AutomationFormTypeEnum>;
}

export const AutomationFormTypeEnum = {
    Artifact: 'artifact',
    Playbook: 'playbook',
    Global: 'global'
} as const;

export type AutomationFormTypeEnum = typeof AutomationFormTypeEnum[keyof typeof AutomationFormTypeEnum];

/**
 * 
 * @export
 * @interface AutomationResponse
 */
export interface AutomationResponse {
    /**
     * 
     * @type {string}
     * @memberof AutomationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AutomationResponse
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof AutomationResponse
     */
    'schema'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutomationResponse
     */
    'script': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutomationResponse
     */
    'type': Array<AutomationResponseTypeEnum>;
}

export const AutomationResponseTypeEnum = {
    Artifact: 'artifact',
    Playbook: 'playbook',
    Global: 'global'
} as const;

export type AutomationResponseTypeEnum = typeof AutomationResponseTypeEnum[keyof typeof AutomationResponseTypeEnum];

/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface CommentForm
 */
export interface CommentForm {
    /**
     * 
     * @type {string}
     * @memberof CommentForm
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentForm
     */
    'creator'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentForm
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface Context
 */
export interface Context {
    /**
     * 
     * @type {Artifact}
     * @memberof Context
     */
    'artifact'?: Artifact;
    /**
     * 
     * @type {PlaybookResponse}
     * @memberof Context
     */
    'playbook'?: PlaybookResponse;
    /**
     * 
     * @type {TaskResponse}
     * @memberof Context
     */
    'task'?: TaskResponse;
    /**
     * 
     * @type {TicketResponse}
     * @memberof Context
     */
    'ticket'?: TicketResponse;
}
/**
 * 
 * @export
 * @interface Dashboard
 */
export interface Dashboard {
    /**
     * 
     * @type {string}
     * @memberof Dashboard
     */
    'name': string;
    /**
     * 
     * @type {Array<Widget>}
     * @memberof Dashboard
     */
    'widgets': Array<Widget>;
}
/**
 * 
 * @export
 * @interface DashboardResponse
 */
export interface DashboardResponse {
    /**
     * 
     * @type {string}
     * @memberof DashboardResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DashboardResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<Widget>}
     * @memberof DashboardResponse
     */
    'widgets': Array<Widget>;
}
/**
 * 
 * @export
 * @interface Enrichment
 */
export interface Enrichment {
    /**
     * 
     * @type {string}
     * @memberof Enrichment
     */
    'created': string;
    /**
     * 
     * @type {object}
     * @memberof Enrichment
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof Enrichment
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EnrichmentForm
 */
export interface EnrichmentForm {
    /**
     * 
     * @type {object}
     * @memberof EnrichmentForm
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof EnrichmentForm
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Graph
 */
export interface Graph {
    /**
     * 
     * @type {Array<Link>}
     * @memberof Graph
     */
    'links'?: Array<Link>;
    /**
     * 
     * @type {Array<Node>}
     * @memberof Graph
     */
    'nodes'?: Array<Node>;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Group
     */
    'users': Array<string>;
}
/**
 * 
 * @export
 * @interface GroupForm
 */
export interface GroupForm {
    /**
     * 
     * @type {string}
     * @memberof GroupForm
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupForm
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupForm
     */
    'users': Array<string>;
}
/**
 * 
 * @export
 * @interface GroupResponse
 */
export interface GroupResponse {
    /**
     * 
     * @type {string}
     * @memberof GroupResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupResponse
     */
    'users': Array<string>;
}
/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'automation': string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'container'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'log'?: string;
    /**
     * 
     * @type {Origin}
     * @memberof Job
     */
    'origin'?: Origin;
    /**
     * 
     * @type {object}
     * @memberof Job
     */
    'output'?: object;
    /**
     * 
     * @type {object}
     * @memberof Job
     */
    'payload'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof Job
     */
    'running': boolean;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface JobForm
 */
export interface JobForm {
    /**
     * 
     * @type {string}
     * @memberof JobForm
     */
    'automation': string;
    /**
     * 
     * @type {Origin}
     * @memberof JobForm
     */
    'origin'?: Origin;
    /**
     * 
     * @type {object}
     * @memberof JobForm
     */
    'payload'?: object;
}
/**
 * 
 * @export
 * @interface JobResponse
 */
export interface JobResponse {
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'automation': string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'container'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'log'?: string;
    /**
     * 
     * @type {Origin}
     * @memberof JobResponse
     */
    'origin'?: Origin;
    /**
     * 
     * @type {object}
     * @memberof JobResponse
     */
    'output'?: object;
    /**
     * 
     * @type {object}
     * @memberof JobResponse
     */
    'payload'?: object;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface JobUpdate
 */
export interface JobUpdate {
    /**
     * 
     * @type {string}
     * @memberof JobUpdate
     */
    'container'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobUpdate
     */
    'log'?: string;
    /**
     * 
     * @type {object}
     * @memberof JobUpdate
     */
    'output'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof JobUpdate
     */
    'running': boolean;
    /**
     * 
     * @type {string}
     * @memberof JobUpdate
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'sid': string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'tid': string;
}
/**
 * 
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {Context}
     * @memberof Message
     */
    'context'?: Context;
    /**
     * 
     * @type {object}
     * @memberof Message
     */
    'payload'?: object;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Message
     */
    'secrets'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface NewUserResponse
 */
export interface NewUserResponse {
    /**
     * 
     * @type {boolean}
     * @memberof NewUserResponse
     */
    'blocked': boolean;
    /**
     * 
     * @type {string}
     * @memberof NewUserResponse
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewUserResponse
     */
    'roles': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NewUserResponse
     */
    'secret'?: string;
}
/**
 * 
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Origin
 */
export interface Origin {
    /**
     * 
     * @type {ArtifactOrigin}
     * @memberof Origin
     */
    'artifact_origin'?: ArtifactOrigin;
    /**
     * 
     * @type {TaskOrigin}
     * @memberof Origin
     */
    'task_origin'?: TaskOrigin;
}
/**
 * 
 * @export
 * @interface Playbook
 */
export interface Playbook {
    /**
     * 
     * @type {string}
     * @memberof Playbook
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: Task; }}
     * @memberof Playbook
     */
    'tasks': { [key: string]: Task; };
}
/**
 * 
 * @export
 * @interface PlaybookResponse
 */
export interface PlaybookResponse {
    /**
     * 
     * @type {string}
     * @memberof PlaybookResponse
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: TaskResponse; }}
     * @memberof PlaybookResponse
     */
    'tasks': { [key: string]: TaskResponse; };
}
/**
 * 
 * @export
 * @interface PlaybookTemplate
 */
export interface PlaybookTemplate {
    /**
     * 
     * @type {string}
     * @memberof PlaybookTemplate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlaybookTemplate
     */
    'yaml': string;
}
/**
 * 
 * @export
 * @interface PlaybookTemplateForm
 */
export interface PlaybookTemplateForm {
    /**
     * 
     * @type {string}
     * @memberof PlaybookTemplateForm
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaybookTemplateForm
     */
    'yaml': string;
}
/**
 * 
 * @export
 * @interface PlaybookTemplateResponse
 */
export interface PlaybookTemplateResponse {
    /**
     * 
     * @type {string}
     * @memberof PlaybookTemplateResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PlaybookTemplateResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlaybookTemplateResponse
     */
    'yaml': string;
}
/**
 * 
 * @export
 * @interface Reference
 */
export interface Reference {
    /**
     * 
     * @type {string}
     * @memberof Reference
     */
    'href': string;
    /**
     * 
     * @type {string}
     * @memberof Reference
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'condition': string;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof Rule
     */
    'update': object;
}
/**
 * 
 * @export
 * @interface RuleForm
 */
export interface RuleForm {
    /**
     * 
     * @type {string}
     * @memberof RuleForm
     */
    'condition': string;
    /**
     * 
     * @type {string}
     * @memberof RuleForm
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleForm
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof RuleForm
     */
    'update': object;
}
/**
 * 
 * @export
 * @interface RuleResponse
 */
export interface RuleResponse {
    /**
     * 
     * @type {string}
     * @memberof RuleResponse
     */
    'condition': string;
    /**
     * 
     * @type {string}
     * @memberof RuleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RuleResponse
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof RuleResponse
     */
    'update': object;
}
/**
 * 
 * @export
 * @interface Settings
 */
export interface Settings {
    /**
     * 
     * @type {Array<Type>}
     * @memberof Settings
     */
    'artifactKinds': Array<Type>;
    /**
     * 
     * @type {Array<Type>}
     * @memberof Settings
     */
    'artifactStates': Array<Type>;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'timeformat': string;
}
/**
 * 
 * @export
 * @interface SettingsResponse
 */
export interface SettingsResponse {
    /**
     * 
     * @type {Array<Type>}
     * @memberof SettingsResponse
     */
    'artifactKinds': Array<Type>;
    /**
     * 
     * @type {Array<Type>}
     * @memberof SettingsResponse
     */
    'artifactStates': Array<Type>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SettingsResponse
     */
    'roles'?: Array<string>;
    /**
     * 
     * @type {Array<TicketTypeResponse>}
     * @memberof SettingsResponse
     */
    'ticketTypes': Array<TicketTypeResponse>;
    /**
     * 
     * @type {string}
     * @memberof SettingsResponse
     */
    'tier': SettingsResponseTierEnum;
    /**
     * 
     * @type {string}
     * @memberof SettingsResponse
     */
    'timeformat': string;
    /**
     * 
     * @type {string}
     * @memberof SettingsResponse
     */
    'version': string;
}

export const SettingsResponseTierEnum = {
    Community: 'community',
    Enterprise: 'enterprise'
} as const;

export type SettingsResponseTierEnum = typeof SettingsResponseTierEnum[keyof typeof SettingsResponseTierEnum];

/**
 * 
 * @export
 * @interface Statistics
 */
export interface Statistics {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof Statistics
     */
    'open_tickets_per_user': { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof Statistics
     */
    'tickets_per_type': { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof Statistics
     */
    'tickets_per_week': { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof Statistics
     */
    'unassigned': number;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'automation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'closed'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'created': string;
    /**
     * 
     * @type {object}
     * @memberof Task
     */
    'data'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof Task
     */
    'done': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Task
     */
    'join'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Task
     */
    'next'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'owner'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Task
     */
    'payload'?: { [key: string]: string; };
    /**
     * 
     * @type {object}
     * @memberof Task
     */
    'schema'?: object;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'type': TaskTypeEnum;
}

export const TaskTypeEnum = {
    Task: 'task',
    Input: 'input',
    Automation: 'automation'
} as const;

export type TaskTypeEnum = typeof TaskTypeEnum[keyof typeof TaskTypeEnum];

/**
 * 
 * @export
 * @interface TaskOrigin
 */
export interface TaskOrigin {
    /**
     * 
     * @type {string}
     * @memberof TaskOrigin
     */
    'playbook_id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskOrigin
     */
    'task_id': string;
    /**
     * 
     * @type {number}
     * @memberof TaskOrigin
     */
    'ticket_id': number;
}
/**
 * 
 * @export
 * @interface TaskResponse
 */
export interface TaskResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TaskResponse
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    'automation'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    'closed'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    'created': string;
    /**
     * 
     * @type {object}
     * @memberof TaskResponse
     */
    'data'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof TaskResponse
     */
    'done': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TaskResponse
     */
    'join'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TaskResponse
     */
    'next'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof TaskResponse
     */
    'order': number;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    'owner'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TaskResponse
     */
    'payload'?: { [key: string]: string; };
    /**
     * 
     * @type {object}
     * @memberof TaskResponse
     */
    'schema'?: object;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    'type': TaskResponseTypeEnum;
}

export const TaskResponseTypeEnum = {
    Task: 'task',
    Input: 'input',
    Automation: 'automation'
} as const;

export type TaskResponseTypeEnum = typeof TaskResponseTypeEnum[keyof typeof TaskResponseTypeEnum];

/**
 * 
 * @export
 * @interface TaskWithContext
 */
export interface TaskWithContext {
    /**
     * 
     * @type {string}
     * @memberof TaskWithContext
     */
    'playbook_id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskWithContext
     */
    'playbook_name': string;
    /**
     * 
     * @type {TaskResponse}
     * @memberof TaskWithContext
     */
    'task': TaskResponse;
    /**
     * 
     * @type {string}
     * @memberof TaskWithContext
     */
    'task_id': string;
    /**
     * 
     * @type {number}
     * @memberof TaskWithContext
     */
    'ticket_id': number;
    /**
     * 
     * @type {string}
     * @memberof TaskWithContext
     */
    'ticket_name': string;
}
/**
 * 
 * @export
 * @interface Ticket
 */
export interface Ticket {
    /**
     * 
     * @type {Array<Artifact>}
     * @memberof Ticket
     */
    'artifacts'?: Array<Artifact>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof Ticket
     */
    'comments'?: Array<Comment>;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'created': string;
    /**
     * 
     * @type {object}
     * @memberof Ticket
     */
    'details'?: object;
    /**
     * 
     * @type {Array<any>}
     * @memberof Ticket
     */
    'files'?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'modified': string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'owner'?: string;
    /**
     * 
     * @type {{ [key: string]: Playbook; }}
     * @memberof Ticket
     */
    'playbooks'?: { [key: string]: Playbook; };
    /**
     * 
     * @type {Array<string>}
     * @memberof Ticket
     */
    'read'?: Array<string>;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof Ticket
     */
    'references'?: Array<Reference>;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'schema': string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Ticket
     */
    'write'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TicketForm
 */
export interface TicketForm {
    /**
     * 
     * @type {Array<Artifact>}
     * @memberof TicketForm
     */
    'artifacts'?: Array<Artifact>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof TicketForm
     */
    'comments'?: Array<Comment>;
    /**
     * 
     * @type {string}
     * @memberof TicketForm
     */
    'created'?: string;
    /**
     * 
     * @type {object}
     * @memberof TicketForm
     */
    'details'?: object;
    /**
     * 
     * @type {Array<any>}
     * @memberof TicketForm
     */
    'files'?: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof TicketForm
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TicketForm
     */
    'modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketForm
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TicketForm
     */
    'owner'?: string;
    /**
     * 
     * @type {Array<PlaybookTemplateForm>}
     * @memberof TicketForm
     */
    'playbooks'?: Array<PlaybookTemplateForm>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketForm
     */
    'read'?: Array<string>;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof TicketForm
     */
    'references'?: Array<Reference>;
    /**
     * 
     * @type {string}
     * @memberof TicketForm
     */
    'schema'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketForm
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof TicketForm
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketForm
     */
    'write'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TicketList
 */
export interface TicketList {
    /**
     * 
     * @type {number}
     * @memberof TicketList
     */
    'count': number;
    /**
     * 
     * @type {Array<TicketSimpleResponse>}
     * @memberof TicketList
     */
    'tickets': Array<TicketSimpleResponse>;
}
/**
 * 
 * @export
 * @interface TicketResponse
 */
export interface TicketResponse {
    /**
     * 
     * @type {Array<Artifact>}
     * @memberof TicketResponse
     */
    'artifacts'?: Array<Artifact>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof TicketResponse
     */
    'comments'?: Array<Comment>;
    /**
     * 
     * @type {string}
     * @memberof TicketResponse
     */
    'created': string;
    /**
     * 
     * @type {object}
     * @memberof TicketResponse
     */
    'details'?: object;
    /**
     * 
     * @type {Array<any>}
     * @memberof TicketResponse
     */
    'files'?: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof TicketResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TicketResponse
     */
    'modified': string;
    /**
     * 
     * @type {string}
     * @memberof TicketResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TicketResponse
     */
    'owner'?: string;
    /**
     * 
     * @type {{ [key: string]: PlaybookResponse; }}
     * @memberof TicketResponse
     */
    'playbooks'?: { [key: string]: PlaybookResponse; };
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketResponse
     */
    'read'?: Array<string>;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof TicketResponse
     */
    'references'?: Array<Reference>;
    /**
     * 
     * @type {string}
     * @memberof TicketResponse
     */
    'schema': string;
    /**
     * 
     * @type {string}
     * @memberof TicketResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof TicketResponse
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketResponse
     */
    'write'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TicketSimpleResponse
 */
export interface TicketSimpleResponse {
    /**
     * 
     * @type {Array<Artifact>}
     * @memberof TicketSimpleResponse
     */
    'artifacts'?: Array<Artifact>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof TicketSimpleResponse
     */
    'comments'?: Array<Comment>;
    /**
     * 
     * @type {string}
     * @memberof TicketSimpleResponse
     */
    'created': string;
    /**
     * 
     * @type {object}
     * @memberof TicketSimpleResponse
     */
    'details'?: object;
    /**
     * 
     * @type {Array<any>}
     * @memberof TicketSimpleResponse
     */
    'files'?: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof TicketSimpleResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TicketSimpleResponse
     */
    'modified': string;
    /**
     * 
     * @type {string}
     * @memberof TicketSimpleResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TicketSimpleResponse
     */
    'owner'?: string;
    /**
     * 
     * @type {{ [key: string]: Playbook; }}
     * @memberof TicketSimpleResponse
     */
    'playbooks'?: { [key: string]: Playbook; };
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketSimpleResponse
     */
    'read'?: Array<string>;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof TicketSimpleResponse
     */
    'references'?: Array<Reference>;
    /**
     * 
     * @type {string}
     * @memberof TicketSimpleResponse
     */
    'schema': string;
    /**
     * 
     * @type {string}
     * @memberof TicketSimpleResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof TicketSimpleResponse
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketSimpleResponse
     */
    'write'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TicketTemplate
 */
export interface TicketTemplate {
    /**
     * 
     * @type {string}
     * @memberof TicketTemplate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TicketTemplate
     */
    'schema': string;
}
/**
 * 
 * @export
 * @interface TicketTemplateForm
 */
export interface TicketTemplateForm {
    /**
     * 
     * @type {string}
     * @memberof TicketTemplateForm
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketTemplateForm
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TicketTemplateForm
     */
    'schema': string;
}
/**
 * 
 * @export
 * @interface TicketTemplateResponse
 */
export interface TicketTemplateResponse {
    /**
     * 
     * @type {string}
     * @memberof TicketTemplateResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TicketTemplateResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TicketTemplateResponse
     */
    'schema': string;
}
/**
 * 
 * @export
 * @interface TicketType
 */
export interface TicketType {
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketType
     */
    'default_groups'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketType
     */
    'default_playbooks': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TicketType
     */
    'default_template': string;
    /**
     * 
     * @type {string}
     * @memberof TicketType
     */
    'icon': string;
    /**
     * 
     * @type {string}
     * @memberof TicketType
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TicketTypeForm
 */
export interface TicketTypeForm {
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketTypeForm
     */
    'default_groups'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketTypeForm
     */
    'default_playbooks': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TicketTypeForm
     */
    'default_template': string;
    /**
     * 
     * @type {string}
     * @memberof TicketTypeForm
     */
    'icon': string;
    /**
     * 
     * @type {string}
     * @memberof TicketTypeForm
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketTypeForm
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TicketTypeResponse
 */
export interface TicketTypeResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketTypeResponse
     */
    'default_groups'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketTypeResponse
     */
    'default_playbooks': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TicketTypeResponse
     */
    'default_template': string;
    /**
     * 
     * @type {string}
     * @memberof TicketTypeResponse
     */
    'icon': string;
    /**
     * 
     * @type {string}
     * @memberof TicketTypeResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TicketTypeResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TicketWithTickets
 */
export interface TicketWithTickets {
    /**
     * 
     * @type {Array<Artifact>}
     * @memberof TicketWithTickets
     */
    'artifacts'?: Array<Artifact>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof TicketWithTickets
     */
    'comments'?: Array<Comment>;
    /**
     * 
     * @type {string}
     * @memberof TicketWithTickets
     */
    'created': string;
    /**
     * 
     * @type {object}
     * @memberof TicketWithTickets
     */
    'details'?: object;
    /**
     * 
     * @type {Array<any>}
     * @memberof TicketWithTickets
     */
    'files'?: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof TicketWithTickets
     */
    'id': number;
    /**
     * 
     * @type {Array<LogEntry>}
     * @memberof TicketWithTickets
     */
    'logs'?: Array<LogEntry>;
    /**
     * 
     * @type {string}
     * @memberof TicketWithTickets
     */
    'modified': string;
    /**
     * 
     * @type {string}
     * @memberof TicketWithTickets
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TicketWithTickets
     */
    'owner'?: string;
    /**
     * 
     * @type {{ [key: string]: PlaybookResponse; }}
     * @memberof TicketWithTickets
     */
    'playbooks'?: { [key: string]: PlaybookResponse; };
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketWithTickets
     */
    'read'?: Array<string>;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof TicketWithTickets
     */
    'references'?: Array<Reference>;
    /**
     * 
     * @type {string}
     * @memberof TicketWithTickets
     */
    'schema': string;
    /**
     * 
     * @type {string}
     * @memberof TicketWithTickets
     */
    'status': string;
    /**
     * 
     * @type {Array<TicketSimpleResponse>}
     * @memberof TicketWithTickets
     */
    'tickets'?: Array<TicketSimpleResponse>;
    /**
     * 
     * @type {string}
     * @memberof TicketWithTickets
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketWithTickets
     */
    'write'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Type
 */
export interface Type {
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    'color'?: TypeColorEnum;
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    'icon': string;
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    'name': string;
}

export const TypeColorEnum = {
    Error: 'error',
    Info: 'info',
    Success: 'success',
    Warning: 'warning'
} as const;

export type TypeColorEnum = typeof TypeColorEnum[keyof typeof TypeColorEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'apikey': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'blocked': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'roles': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'sha256'?: string;
}
/**
 * 
 * @export
 * @interface UserData
 */
export interface UserData {
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'timeformat'?: string;
}
/**
 * 
 * @export
 * @interface UserDataResponse
 */
export interface UserDataResponse {
    /**
     * 
     * @type {string}
     * @memberof UserDataResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDataResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserDataResponse
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDataResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDataResponse
     */
    'timeformat'?: string;
}
/**
 * 
 * @export
 * @interface UserForm
 */
export interface UserForm {
    /**
     * 
     * @type {boolean}
     * @memberof UserForm
     */
    'apikey': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserForm
     */
    'blocked': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserForm
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserForm
     */
    'password'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserForm
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    'apikey': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    'blocked': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResponse
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface Widget
 */
export interface Widget {
    /**
     * 
     * @type {string}
     * @memberof Widget
     */
    'aggregation': string;
    /**
     * 
     * @type {string}
     * @memberof Widget
     */
    'filter'?: string;
    /**
     * 
     * @type {string}
     * @memberof Widget
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Widget
     */
    'type': WidgetTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Widget
     */
    'width': number;
}

export const WidgetTypeEnum = {
    Bar: 'bar',
    Line: 'line',
    Pie: 'pie'
} as const;

export type WidgetTypeEnum = typeof WidgetTypeEnum[keyof typeof WidgetTypeEnum];


/**
 * AutomationsApi - axios parameter creator
 * @export
 */
export const AutomationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new automation
         * @param {AutomationForm} automation New automation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutomation: async (automation: AutomationForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'automation' is not null or undefined
            assertParamExists('createAutomation', 'automation', automation)
            const localVarPath = `/automations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a automation
         * @param {string} id Automation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAutomation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAutomation', 'id', id)
            const localVarPath = `/automations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single automation
         * @param {string} id Automation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutomation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAutomation', 'id', id)
            const localVarPath = `/automations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List automations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAutomations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/automations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing automation
         * @param {string} id Automation ID
         * @param {AutomationForm} automation Automation object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutomation: async (id: string, automation: AutomationForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAutomation', 'id', id)
            // verify required parameter 'automation' is not null or undefined
            assertParamExists('updateAutomation', 'automation', automation)
            const localVarPath = `/automations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutomationsApi - functional programming interface
 * @export
 */
export const AutomationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutomationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new automation
         * @param {AutomationForm} automation New automation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAutomation(automation: AutomationForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAutomation(automation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a automation
         * @param {string} id Automation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAutomation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAutomation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single automation
         * @param {string} id Automation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutomation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutomation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List automations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAutomations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutomationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAutomations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing automation
         * @param {string} id Automation ID
         * @param {AutomationForm} automation Automation object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAutomation(id: string, automation: AutomationForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAutomation(id, automation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AutomationsApi - factory interface
 * @export
 */
export const AutomationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutomationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new automation
         * @param {AutomationForm} automation New automation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutomation(automation: AutomationForm, options?: any): AxiosPromise<AutomationResponse> {
            return localVarFp.createAutomation(automation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a automation
         * @param {string} id Automation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAutomation(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAutomation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single automation
         * @param {string} id Automation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutomation(id: string, options?: any): AxiosPromise<AutomationResponse> {
            return localVarFp.getAutomation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List automations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAutomations(options?: any): AxiosPromise<Array<AutomationResponse>> {
            return localVarFp.listAutomations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing automation
         * @param {string} id Automation ID
         * @param {AutomationForm} automation Automation object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutomation(id: string, automation: AutomationForm, options?: any): AxiosPromise<AutomationResponse> {
            return localVarFp.updateAutomation(id, automation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutomationsApi - object-oriented interface
 * @export
 * @class AutomationsApi
 * @extends {BaseAPI}
 */
export class AutomationsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new automation
     * @param {AutomationForm} automation New automation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsApi
     */
    public createAutomation(automation: AutomationForm, options?: AxiosRequestConfig) {
        return AutomationsApiFp(this.configuration).createAutomation(automation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a automation
     * @param {string} id Automation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsApi
     */
    public deleteAutomation(id: string, options?: AxiosRequestConfig) {
        return AutomationsApiFp(this.configuration).deleteAutomation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single automation
     * @param {string} id Automation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsApi
     */
    public getAutomation(id: string, options?: AxiosRequestConfig) {
        return AutomationsApiFp(this.configuration).getAutomation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List automations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsApi
     */
    public listAutomations(options?: AxiosRequestConfig) {
        return AutomationsApiFp(this.configuration).listAutomations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing automation
     * @param {string} id Automation ID
     * @param {AutomationForm} automation Automation object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsApi
     */
    public updateAutomation(id: string, automation: AutomationForm, options?: AxiosRequestConfig) {
        return AutomationsApiFp(this.configuration).updateAutomation(id, automation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DashboardsApi - axios parameter creator
 * @export
 */
export const DashboardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new dashboard
         * @param {Dashboard} template New template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboard: async (template: Dashboard, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'template' is not null or undefined
            assertParamExists('createDashboard', 'template', template)
            const localVarPath = `/dashboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(template, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get widget data
         * @param {string} aggregation Aggregation
         * @param {string} [filter] Filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardData: async (aggregation: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aggregation' is not null or undefined
            assertParamExists('dashboardData', 'aggregation', aggregation)
            const localVarPath = `/dashboard/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (aggregation !== undefined) {
                localVarQueryParameter['aggregation'] = aggregation;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a dashboard
         * @param {string} id Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDashboard', 'id', id)
            const localVarPath = `/dashboards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single dashboard
         * @param {string} id Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDashboard', 'id', id)
            const localVarPath = `/dashboards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List dashboards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDashboards: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing dashboard
         * @param {string} id Dashboard ID
         * @param {Dashboard} dashboard Dashboard object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboard: async (id: string, dashboard: Dashboard, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDashboard', 'id', id)
            // verify required parameter 'dashboard' is not null or undefined
            assertParamExists('updateDashboard', 'dashboard', dashboard)
            const localVarPath = `/dashboards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dashboard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardsApi - functional programming interface
 * @export
 */
export const DashboardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new dashboard
         * @param {Dashboard} template New template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDashboard(template: Dashboard, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDashboard(template, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get widget data
         * @param {string} aggregation Aggregation
         * @param {string} [filter] Filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardData(aggregation: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardData(aggregation, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a dashboard
         * @param {string} id Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDashboard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDashboard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single dashboard
         * @param {string} id Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List dashboards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDashboards(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DashboardResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDashboards(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing dashboard
         * @param {string} id Dashboard ID
         * @param {Dashboard} dashboard Dashboard object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDashboard(id: string, dashboard: Dashboard, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDashboard(id, dashboard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DashboardsApi - factory interface
 * @export
 */
export const DashboardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new dashboard
         * @param {Dashboard} template New template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboard(template: Dashboard, options?: any): AxiosPromise<DashboardResponse> {
            return localVarFp.createDashboard(template, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get widget data
         * @param {string} aggregation Aggregation
         * @param {string} [filter] Filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardData(aggregation: string, filter?: string, options?: any): AxiosPromise<object> {
            return localVarFp.dashboardData(aggregation, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a dashboard
         * @param {string} id Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboard(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDashboard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single dashboard
         * @param {string} id Dashboard ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard(id: string, options?: any): AxiosPromise<DashboardResponse> {
            return localVarFp.getDashboard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List dashboards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDashboards(options?: any): AxiosPromise<Array<DashboardResponse>> {
            return localVarFp.listDashboards(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing dashboard
         * @param {string} id Dashboard ID
         * @param {Dashboard} dashboard Dashboard object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboard(id: string, dashboard: Dashboard, options?: any): AxiosPromise<DashboardResponse> {
            return localVarFp.updateDashboard(id, dashboard, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardsApi - object-oriented interface
 * @export
 * @class DashboardsApi
 * @extends {BaseAPI}
 */
export class DashboardsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new dashboard
     * @param {Dashboard} template New template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public createDashboard(template: Dashboard, options?: AxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).createDashboard(template, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get widget data
     * @param {string} aggregation Aggregation
     * @param {string} [filter] Filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public dashboardData(aggregation: string, filter?: string, options?: AxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).dashboardData(aggregation, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a dashboard
     * @param {string} id Dashboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public deleteDashboard(id: string, options?: AxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).deleteDashboard(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single dashboard
     * @param {string} id Dashboard ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public getDashboard(id: string, options?: AxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).getDashboard(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List dashboards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public listDashboards(options?: AxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).listDashboards(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing dashboard
     * @param {string} id Dashboard ID
     * @param {Dashboard} dashboard Dashboard object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public updateDashboard(id: string, dashboard: Dashboard, options?: AxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).updateDashboard(id, dashboard, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GraphApi - axios parameter creator
 * @export
 */
export const GraphApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Graph
         * @param {string} col Graph Start
         * @param {string} id Graph Start
         * @param {number} depth Graph Start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        graph: async (col: string, id: string, depth: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'col' is not null or undefined
            assertParamExists('graph', 'col', col)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('graph', 'id', id)
            // verify required parameter 'depth' is not null or undefined
            assertParamExists('graph', 'depth', depth)
            const localVarPath = `/graph/{col}/{id}`
                .replace(`{${"col"}}`, encodeURIComponent(String(col)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphApi - functional programming interface
 * @export
 */
export const GraphApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Graph
         * @param {string} col Graph Start
         * @param {string} id Graph Start
         * @param {number} depth Graph Start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async graph(col: string, id: string, depth: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Graph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.graph(col, id, depth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GraphApi - factory interface
 * @export
 */
export const GraphApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphApiFp(configuration)
    return {
        /**
         * 
         * @summary Graph
         * @param {string} col Graph Start
         * @param {string} id Graph Start
         * @param {number} depth Graph Start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        graph(col: string, id: string, depth: number, options?: any): AxiosPromise<Graph> {
            return localVarFp.graph(col, id, depth, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphApi - object-oriented interface
 * @export
 * @class GraphApi
 * @extends {BaseAPI}
 */
export class GraphApi extends BaseAPI {
    /**
     * 
     * @summary Graph
     * @param {string} col Graph Start
     * @param {string} id Graph Start
     * @param {number} depth Graph Start
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public graph(col: string, id: string, depth: number, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).graph(col, id, depth, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new group
         * @param {GroupForm} group New group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (group: GroupForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('createGroup', 'group', group)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a group
         * @param {string} id Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single group
         * @param {string} id Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing group
         * @param {string} id Group ID
         * @param {Group} group Group object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (id: string, group: Group, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGroup', 'id', id)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('updateGroup', 'group', group)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new group
         * @param {GroupForm} group New group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(group: GroupForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a group
         * @param {string} id Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single group
         * @param {string} id Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing group
         * @param {string} id Group ID
         * @param {Group} group Group object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(id: string, group: Group, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(id, group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new group
         * @param {GroupForm} group New group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: GroupForm, options?: any): AxiosPromise<GroupResponse> {
            return localVarFp.createGroup(group, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a group
         * @param {string} id Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single group
         * @param {string} id Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(id: string, options?: any): AxiosPromise<GroupResponse> {
            return localVarFp.getGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(options?: any): AxiosPromise<Array<Group>> {
            return localVarFp.listGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing group
         * @param {string} id Group ID
         * @param {Group} group Group object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(id: string, group: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.updateGroup(id, group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new group
     * @param {GroupForm} group New group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(group: GroupForm, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroup(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a group
     * @param {string} id Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroup(id: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single group
     * @param {string} id Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroup(id: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public listGroups(options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).listGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing group
     * @param {string} id Group ID
     * @param {Group} group Group object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroup(id: string, group: Group, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroup(id, group, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single job
         * @param {string} id Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getJob', 'id', id)
            const localVarPath = `/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a new job
         * @param {JobForm} job New job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runJob: async (job: JobForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'job' is not null or undefined
            assertParamExists('runJob', 'job', job)
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(job, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing job
         * @param {string} id Job ID
         * @param {JobUpdate} job Job object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJob: async (id: string, job: JobUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateJob', 'id', id)
            // verify required parameter 'job' is not null or undefined
            assertParamExists('updateJob', 'job', job)
            const localVarPath = `/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(job, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single job
         * @param {string} id Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobs(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<JobResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start a new job
         * @param {JobForm} job New job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runJob(job: JobForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runJob(job, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing job
         * @param {string} id Job ID
         * @param {JobUpdate} job Job object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJob(id: string, job: JobUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateJob(id, job, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single job
         * @param {string} id Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(id: string, options?: any): AxiosPromise<JobResponse> {
            return localVarFp.getJob(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(options?: any): AxiosPromise<Array<JobResponse>> {
            return localVarFp.listJobs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a new job
         * @param {JobForm} job New job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runJob(job: JobForm, options?: any): AxiosPromise<JobResponse> {
            return localVarFp.runJob(job, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing job
         * @param {string} id Job ID
         * @param {JobUpdate} job Job object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJob(id: string, job: JobUpdate, options?: any): AxiosPromise<JobResponse> {
            return localVarFp.updateJob(id, job, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single job
     * @param {string} id Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJob(id: string, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).getJob(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List jobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public listJobs(options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).listJobs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a new job
     * @param {JobForm} job New job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public runJob(job: JobForm, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).runJob(job, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing job
     * @param {string} id Job ID
     * @param {JobUpdate} job Job object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public updateJob(id: string, job: JobUpdate, options?: AxiosRequestConfig) {
        return JobsApiFp(this.configuration).updateJob(id, job, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get log entries
         * @param {string} reference Reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogs: async (reference: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reference' is not null or undefined
            assertParamExists('getLogs', 'reference', reference)
            const localVarPath = `/logs/{reference}`
                .replace(`{${"reference"}}`, encodeURIComponent(String(reference)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get log entries
         * @param {string} reference Reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogs(reference: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogs(reference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get log entries
         * @param {string} reference Reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogs(reference: string, options?: any): AxiosPromise<Array<LogEntry>> {
            return localVarFp.getLogs(reference, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI {
    /**
     * 
     * @summary Get log entries
     * @param {string} reference Reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public getLogs(reference: string, options?: AxiosRequestConfig) {
        return LogsApiFp(this.configuration).getLogs(reference, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlaybooksApi - axios parameter creator
 * @export
 */
export const PlaybooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a playbook
         * @param {PlaybookTemplateForm} playbook New playbook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaybook: async (playbook: PlaybookTemplateForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playbook' is not null or undefined
            assertParamExists('createPlaybook', 'playbook', playbook)
            const localVarPath = `/playbooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playbook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a playbook
         * @param {string} id Playbook name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaybook: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePlaybook', 'id', id)
            const localVarPath = `/playbooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single playbook
         * @param {string} id Playbook name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybook: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlaybook', 'id', id)
            const localVarPath = `/playbooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List playbooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaybooks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/playbooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing ticket playbook
         * @param {string} id Playbook ID
         * @param {PlaybookTemplateForm} playbook Updated playbook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaybook: async (id: string, playbook: PlaybookTemplateForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePlaybook', 'id', id)
            // verify required parameter 'playbook' is not null or undefined
            assertParamExists('updatePlaybook', 'playbook', playbook)
            const localVarPath = `/playbooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playbook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaybooksApi - functional programming interface
 * @export
 */
export const PlaybooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaybooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a playbook
         * @param {PlaybookTemplateForm} playbook New playbook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaybook(playbook: PlaybookTemplateForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaybookTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlaybook(playbook, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a playbook
         * @param {string} id Playbook name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlaybook(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaybook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single playbook
         * @param {string} id Playbook name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaybook(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaybookTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaybook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List playbooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlaybooks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlaybookTemplateResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlaybooks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing ticket playbook
         * @param {string} id Playbook ID
         * @param {PlaybookTemplateForm} playbook Updated playbook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlaybook(id: string, playbook: PlaybookTemplateForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaybookTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlaybook(id, playbook, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlaybooksApi - factory interface
 * @export
 */
export const PlaybooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaybooksApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a playbook
         * @param {PlaybookTemplateForm} playbook New playbook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaybook(playbook: PlaybookTemplateForm, options?: any): AxiosPromise<PlaybookTemplateResponse> {
            return localVarFp.createPlaybook(playbook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a playbook
         * @param {string} id Playbook name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaybook(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePlaybook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single playbook
         * @param {string} id Playbook name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybook(id: string, options?: any): AxiosPromise<PlaybookTemplateResponse> {
            return localVarFp.getPlaybook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List playbooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaybooks(options?: any): AxiosPromise<Array<PlaybookTemplateResponse>> {
            return localVarFp.listPlaybooks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing ticket playbook
         * @param {string} id Playbook ID
         * @param {PlaybookTemplateForm} playbook Updated playbook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaybook(id: string, playbook: PlaybookTemplateForm, options?: any): AxiosPromise<PlaybookTemplateResponse> {
            return localVarFp.updatePlaybook(id, playbook, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaybooksApi - object-oriented interface
 * @export
 * @class PlaybooksApi
 * @extends {BaseAPI}
 */
export class PlaybooksApi extends BaseAPI {
    /**
     * 
     * @summary Create a playbook
     * @param {PlaybookTemplateForm} playbook New playbook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaybooksApi
     */
    public createPlaybook(playbook: PlaybookTemplateForm, options?: AxiosRequestConfig) {
        return PlaybooksApiFp(this.configuration).createPlaybook(playbook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a playbook
     * @param {string} id Playbook name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaybooksApi
     */
    public deletePlaybook(id: string, options?: AxiosRequestConfig) {
        return PlaybooksApiFp(this.configuration).deletePlaybook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single playbook
     * @param {string} id Playbook name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaybooksApi
     */
    public getPlaybook(id: string, options?: AxiosRequestConfig) {
        return PlaybooksApiFp(this.configuration).getPlaybook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List playbooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaybooksApi
     */
    public listPlaybooks(options?: AxiosRequestConfig) {
        return PlaybooksApiFp(this.configuration).listPlaybooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing ticket playbook
     * @param {string} id Playbook ID
     * @param {PlaybookTemplateForm} playbook Updated playbook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaybooksApi
     */
    public updatePlaybook(id: string, playbook: PlaybookTemplateForm, options?: AxiosRequestConfig) {
        return PlaybooksApiFp(this.configuration).updatePlaybook(id, playbook, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RulesApi - axios parameter creator
 * @export
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a rule
         * @param {RuleForm} rule New rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRule: async (rule: RuleForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('createRule', 'rule', rule)
            const localVarPath = `/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a rule
         * @param {string} id Rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRule', 'id', id)
            const localVarPath = `/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single rule
         * @param {string} id Rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRule', 'id', id)
            const localVarPath = `/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRules: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing ticket rule
         * @param {string} id Rule ID
         * @param {RuleForm} rule Updated rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRule: async (id: string, rule: RuleForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRule', 'id', id)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('updateRule', 'rule', rule)
            const localVarPath = `/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 * @export
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a rule
         * @param {RuleForm} rule New rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRule(rule: RuleForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRule(rule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a rule
         * @param {string} id Rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRule(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single rule
         * @param {string} id Rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRule(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRules(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRules(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing ticket rule
         * @param {string} id Rule ID
         * @param {RuleForm} rule Updated rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRule(id: string, rule: RuleForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRule(id, rule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RulesApi - factory interface
 * @export
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a rule
         * @param {RuleForm} rule New rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRule(rule: RuleForm, options?: any): AxiosPromise<Array<RuleResponse>> {
            return localVarFp.createRule(rule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a rule
         * @param {string} id Rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single rule
         * @param {string} id Rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule(id: string, options?: any): AxiosPromise<RuleResponse> {
            return localVarFp.getRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRules(options?: any): AxiosPromise<Array<RuleResponse>> {
            return localVarFp.listRules(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing ticket rule
         * @param {string} id Rule ID
         * @param {RuleForm} rule Updated rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRule(id: string, rule: RuleForm, options?: any): AxiosPromise<RuleResponse> {
            return localVarFp.updateRule(id, rule, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
export class RulesApi extends BaseAPI {
    /**
     * 
     * @summary Create a rule
     * @param {RuleForm} rule New rule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public createRule(rule: RuleForm, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).createRule(rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a rule
     * @param {string} id Rule name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public deleteRule(id: string, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).deleteRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single rule
     * @param {string} id Rule name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getRule(id: string, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).getRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public listRules(options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).listRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing ticket rule
     * @param {string} id Rule ID
     * @param {RuleForm} rule Updated rule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public updateRule(id: string, rule: RuleForm, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).updateRule(id, rule, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save settings
         * @param {Settings} settings Save settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSettings: async (settings: Settings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settings' is not null or undefined
            assertParamExists('saveSettings', 'settings', settings)
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Save settings
         * @param {Settings} settings Save settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveSettings(settings: Settings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveSettings(settings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(options?: any): AxiosPromise<SettingsResponse> {
            return localVarFp.getSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Save settings
         * @param {Settings} settings Save settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSettings(settings: Settings, options?: any): AxiosPromise<SettingsResponse> {
            return localVarFp.saveSettings(settings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getSettings(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Save settings
     * @param {Settings} settings Save settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public saveSettings(settings: Settings, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).saveSettings(settings, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatisticsApi - axios parameter creator
 * @export
 */
export const StatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatistics: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatisticsApi - functional programming interface
 * @export
 */
export const StatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatistics(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Statistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatistics(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatisticsApi - factory interface
 * @export
 */
export const StatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatisticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatistics(options?: any): AxiosPromise<Statistics> {
            return localVarFp.getStatistics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatisticsApi - object-oriented interface
 * @export
 * @class StatisticsApi
 * @extends {BaseAPI}
 */
export class StatisticsApi extends BaseAPI {
    /**
     * 
     * @summary Get statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public getStatistics(options?: AxiosRequestConfig) {
        return StatisticsApiFp(this.configuration).getStatistics(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTasks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskWithContext>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTasks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * 
         * @summary List tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(options?: any): AxiosPromise<Array<TaskWithContext>> {
            return localVarFp.listTasks(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * 
     * @summary List tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public listTasks(options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).listTasks(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new template
         * @param {TicketTemplateForm} template New template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: async (template: TicketTemplateForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'template' is not null or undefined
            assertParamExists('createTemplate', 'template', template)
            const localVarPath = `/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(template, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a template
         * @param {string} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTemplate', 'id', id)
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single template
         * @param {string} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTemplate', 'id', id)
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing template
         * @param {string} id Template ID
         * @param {TicketTemplateForm} template Template object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate: async (id: string, template: TicketTemplateForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTemplate', 'id', id)
            // verify required parameter 'template' is not null or undefined
            assertParamExists('updateTemplate', 'template', template)
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(template, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new template
         * @param {TicketTemplateForm} template New template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTemplate(template: TicketTemplateForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTemplate(template, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a template
         * @param {string} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTemplate(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTemplate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single template
         * @param {string} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplate(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTemplates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TicketTemplateResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTemplates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing template
         * @param {string} id Template ID
         * @param {TicketTemplateForm} template Template object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTemplate(id: string, template: TicketTemplateForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTemplate(id, template, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new template
         * @param {TicketTemplateForm} template New template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(template: TicketTemplateForm, options?: any): AxiosPromise<TicketTemplateResponse> {
            return localVarFp.createTemplate(template, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a template
         * @param {string} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTemplate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single template
         * @param {string} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(id: string, options?: any): AxiosPromise<TicketTemplateResponse> {
            return localVarFp.getTemplate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(options?: any): AxiosPromise<Array<TicketTemplateResponse>> {
            return localVarFp.listTemplates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing template
         * @param {string} id Template ID
         * @param {TicketTemplateForm} template Template object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(id: string, template: TicketTemplateForm, options?: any): AxiosPromise<TicketTemplateResponse> {
            return localVarFp.updateTemplate(id, template, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new template
     * @param {TicketTemplateForm} template New template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public createTemplate(template: TicketTemplateForm, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).createTemplate(template, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a template
     * @param {string} id Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public deleteTemplate(id: string, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).deleteTemplate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single template
     * @param {string} id Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getTemplate(id: string, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).getTemplate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public listTemplates(options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).listTemplates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing template
     * @param {string} id Template ID
     * @param {TicketTemplateForm} template Template object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public updateTemplate(id: string, template: TicketTemplateForm, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).updateTemplate(id, template, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TicketsApi - axios parameter creator
 * @export
 */
export const TicketsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a single artifact
         * @param {number} id Ticket ID
         * @param {Artifact} artifact Artifact object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArtifact: async (id: number, artifact: Artifact, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addArtifact', 'id', id)
            // verify required parameter 'artifact' is not null or undefined
            assertParamExists('addArtifact', 'artifact', artifact)
            const localVarPath = `/tickets/{id}/artifacts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add ticket comment
         * @param {number} id Ticket ID
         * @param {CommentForm} comment Ticket comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addComment: async (id: number, comment: CommentForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addComment', 'id', id)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('addComment', 'comment', comment)
            const localVarPath = `/tickets/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(comment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new ticket playbook
         * @param {number} id Ticket ID
         * @param {PlaybookTemplateForm} playbook Ticket playbook object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTicketPlaybook: async (id: number, playbook: PlaybookTemplateForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addTicketPlaybook', 'id', id)
            // verify required parameter 'playbook' is not null or undefined
            assertParamExists('addTicketPlaybook', 'playbook', playbook)
            const localVarPath = `/tickets/{id}/playbooks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playbook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete ticket playbook task
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {string} taskID Task ID
         * @param {object} data Ticket playbook object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask: async (id: number, playbookID: string, taskID: string, data: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeTask', 'id', id)
            // verify required parameter 'playbookID' is not null or undefined
            assertParamExists('completeTask', 'playbookID', playbookID)
            // verify required parameter 'taskID' is not null or undefined
            assertParamExists('completeTask', 'taskID', taskID)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('completeTask', 'data', data)
            const localVarPath = `/tickets/{id}/playbooks/{playbookID}/task/{taskID}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"playbookID"}}`, encodeURIComponent(String(playbookID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new ticket
         * @param {TicketForm} ticket New ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket: async (ticket: TicketForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticket' is not null or undefined
            assertParamExists('createTicket', 'ticket', ticket)
            const localVarPath = `/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new tickets in batch
         * @param {Array<TicketForm>} ticket New ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketBatch: async (ticket: Array<TicketForm>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticket' is not null or undefined
            assertParamExists('createTicketBatch', 'ticket', ticket)
            const localVarPath = `/tickets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an ticket
         * @param {number} id Ticket ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicket: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTicket', 'id', id)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enrich a single artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {EnrichmentForm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrichArtifact: async (id: number, name: string, data: EnrichmentForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enrichArtifact', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('enrichArtifact', 'name', name)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('enrichArtifact', 'data', data)
            const localVarPath = `/tickets/{id}/artifacts/{name}/enrich`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact: async (id: number, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getArtifact', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getArtifact', 'name', name)
            const localVarPath = `/tickets/{id}/artifacts/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single ticket
         * @param {number} id Ticket ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicket: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTicket', 'id', id)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link an ticket to an ticket
         * @param {number} id Ticket ID
         * @param {number} linkedID Added ticket ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkTicket: async (id: number, linkedID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('linkTicket', 'id', id)
            // verify required parameter 'linkedID' is not null or undefined
            assertParamExists('linkTicket', 'linkedID', linkedID)
            const localVarPath = `/tickets/{id}/tickets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(linkedID, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tickets
         * @param {string} [type] Ticket Type
         * @param {number} [offset] Offset of the list
         * @param {number} [count] Number of tickets
         * @param {Array<string>} [sort] Sort columns
         * @param {Array<boolean>} [desc] Sort descending
         * @param {string} [query] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickets: async (type?: string, offset?: number, count?: number, sort?: Array<string>, desc?: Array<boolean>, query?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (desc) {
                localVarQueryParameter['desc'] = desc.join(COLLECTION_FORMATS.csv);
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeArtifact: async (id: number, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeArtifact', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('removeArtifact', 'name', name)
            const localVarPath = `/tickets/{id}/artifacts/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Comment will be removed from the ticket.
         * @summary Remove an comment from an ticket
         * @param {number} id Ticket ID
         * @param {number} commentID Comment ID to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeComment: async (id: number, commentID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeComment', 'id', id)
            // verify required parameter 'commentID' is not null or undefined
            assertParamExists('removeComment', 'commentID', commentID)
            const localVarPath = `/tickets/{id}/comments/{commentID}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"commentID"}}`, encodeURIComponent(String(commentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an ticket playbook
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTicketPlaybook: async (id: number, playbookID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeTicketPlaybook', 'id', id)
            // verify required parameter 'playbookID' is not null or undefined
            assertParamExists('removeTicketPlaybook', 'playbookID', playbookID)
            const localVarPath = `/tickets/{id}/playbooks/{playbookID}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"playbookID"}}`, encodeURIComponent(String(playbookID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run automation on a single artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {string} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runArtifact: async (id: number, name: string, automation: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runArtifact', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('runArtifact', 'name', name)
            // verify required parameter 'automation' is not null or undefined
            assertParamExists('runArtifact', 'automation', automation)
            const localVarPath = `/tickets/{id}/artifacts/{name}/run/{automation}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"automation"}}`, encodeURIComponent(String(automation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run ticket playbook task
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {string} taskID Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTask: async (id: number, playbookID: string, taskID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runTask', 'id', id)
            // verify required parameter 'playbookID' is not null or undefined
            assertParamExists('runTask', 'playbookID', playbookID)
            // verify required parameter 'taskID' is not null or undefined
            assertParamExists('runTask', 'taskID', taskID)
            const localVarPath = `/tickets/{id}/playbooks/{playbookID}/task/{taskID}/run`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"playbookID"}}`, encodeURIComponent(String(playbookID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a single artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {Artifact} artifact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setArtifact: async (id: number, name: string, artifact: Artifact, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setArtifact', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('setArtifact', 'name', name)
            // verify required parameter 'artifact' is not null or undefined
            assertParamExists('setArtifact', 'artifact', artifact)
            const localVarPath = `/tickets/{id}/artifacts/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set ticket references
         * @param {number} id Ticket ID
         * @param {Array<Reference>} references All ticket references
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReferences: async (id: number, references: Array<Reference>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setReferences', 'id', id)
            // verify required parameter 'references' is not null or undefined
            assertParamExists('setReferences', 'references', references)
            const localVarPath = `/tickets/{id}/references`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(references, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set ticket schema
         * @param {number} id Ticket ID
         * @param {string} schema New ticket schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchema: async (id: number, schema: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setSchema', 'id', id)
            // verify required parameter 'schema' is not null or undefined
            assertParamExists('setSchema', 'schema', schema)
            const localVarPath = `/tickets/{id}/schema`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a ticket playbook task data
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {string} taskID Task ID
         * @param {object} data Task data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTaskData: async (id: number, playbookID: string, taskID: string, data: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setTaskData', 'id', id)
            // verify required parameter 'playbookID' is not null or undefined
            assertParamExists('setTaskData', 'playbookID', playbookID)
            // verify required parameter 'taskID' is not null or undefined
            assertParamExists('setTaskData', 'taskID', taskID)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('setTaskData', 'data', data)
            const localVarPath = `/tickets/{id}/playbooks/{playbookID}/task/{taskID}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"playbookID"}}`, encodeURIComponent(String(playbookID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a ticket playbook task owner
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {string} taskID Task ID
         * @param {string} owner Task owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTaskOwner: async (id: number, playbookID: string, taskID: string, owner: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setTaskOwner', 'id', id)
            // verify required parameter 'playbookID' is not null or undefined
            assertParamExists('setTaskOwner', 'playbookID', playbookID)
            // verify required parameter 'taskID' is not null or undefined
            assertParamExists('setTaskOwner', 'taskID', taskID)
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('setTaskOwner', 'owner', owner)
            const localVarPath = `/tickets/{id}/playbooks/{playbookID}/task/{taskID}/owner`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"playbookID"}}`, encodeURIComponent(String(playbookID)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(owner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink an ticket to an ticket
         * @param {number} id Ticket ID
         * @param {number} linkedID Added ticket ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkTicket: async (id: number, linkedID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unlinkTicket', 'id', id)
            // verify required parameter 'linkedID' is not null or undefined
            assertParamExists('unlinkTicket', 'linkedID', linkedID)
            const localVarPath = `/tickets/{id}/tickets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(linkedID, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing ticket
         * @param {number} id Ticket ID
         * @param {Ticket} ticket Updated ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicket: async (id: number, ticket: Ticket, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTicket', 'id', id)
            // verify required parameter 'ticket' is not null or undefined
            assertParamExists('updateTicket', 'ticket', ticket)
            const localVarPath = `/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TicketsApi - functional programming interface
 * @export
 */
export const TicketsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TicketsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a single artifact
         * @param {number} id Ticket ID
         * @param {Artifact} artifact Artifact object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addArtifact(id: number, artifact: Artifact, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addArtifact(id, artifact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add ticket comment
         * @param {number} id Ticket ID
         * @param {CommentForm} comment Ticket comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addComment(id: number, comment: CommentForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addComment(id, comment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new ticket playbook
         * @param {number} id Ticket ID
         * @param {PlaybookTemplateForm} playbook Ticket playbook object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTicketPlaybook(id: number, playbook: PlaybookTemplateForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTicketPlaybook(id, playbook, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Complete ticket playbook task
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {string} taskID Task ID
         * @param {object} data Ticket playbook object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTask(id: number, playbookID: string, taskID: string, data: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeTask(id, playbookID, taskID, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new ticket
         * @param {TicketForm} ticket New ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicket(ticket: TicketForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicket(ticket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new tickets in batch
         * @param {Array<TicketForm>} ticket New ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicketBatch(ticket: Array<TicketForm>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicketBatch(ticket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an ticket
         * @param {number} id Ticket ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTicket(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTicket(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Enrich a single artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {EnrichmentForm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enrichArtifact(id: number, name: string, data: EnrichmentForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enrichArtifact(id, name, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifact(id: number, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Artifact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifact(id, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single ticket
         * @param {number} id Ticket ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicket(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicket(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Link an ticket to an ticket
         * @param {number} id Ticket ID
         * @param {number} linkedID Added ticket ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkTicket(id: number, linkedID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkTicket(id, linkedID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List tickets
         * @param {string} [type] Ticket Type
         * @param {number} [offset] Offset of the list
         * @param {number} [count] Number of tickets
         * @param {Array<string>} [sort] Sort columns
         * @param {Array<boolean>} [desc] Sort descending
         * @param {string} [query] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTickets(type?: string, offset?: number, count?: number, sort?: Array<string>, desc?: Array<boolean>, query?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTickets(type, offset, count, sort, desc, query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove an artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeArtifact(id: number, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeArtifact(id, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Comment will be removed from the ticket.
         * @summary Remove an comment from an ticket
         * @param {number} id Ticket ID
         * @param {number} commentID Comment ID to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeComment(id: number, commentID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeComment(id, commentID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove an ticket playbook
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTicketPlaybook(id: number, playbookID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTicketPlaybook(id, playbookID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run automation on a single artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {string} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runArtifact(id: number, name: string, automation: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runArtifact(id, name, automation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run ticket playbook task
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {string} taskID Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runTask(id: number, playbookID: string, taskID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runTask(id, playbookID, taskID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set a single artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {Artifact} artifact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setArtifact(id: number, name: string, artifact: Artifact, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setArtifact(id, name, artifact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set ticket references
         * @param {number} id Ticket ID
         * @param {Array<Reference>} references All ticket references
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setReferences(id: number, references: Array<Reference>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setReferences(id, references, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set ticket schema
         * @param {number} id Ticket ID
         * @param {string} schema New ticket schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSchema(id: number, schema: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSchema(id, schema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set a ticket playbook task data
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {string} taskID Task ID
         * @param {object} data Task data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTaskData(id: number, playbookID: string, taskID: string, data: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTaskData(id, playbookID, taskID, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set a ticket playbook task owner
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {string} taskID Task ID
         * @param {string} owner Task owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTaskOwner(id: number, playbookID: string, taskID: string, owner: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTaskOwner(id, playbookID, taskID, owner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlink an ticket to an ticket
         * @param {number} id Ticket ID
         * @param {number} linkedID Added ticket ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkTicket(id: number, linkedID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkTicket(id, linkedID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing ticket
         * @param {number} id Ticket ID
         * @param {Ticket} ticket Updated ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTicket(id: number, ticket: Ticket, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketWithTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTicket(id, ticket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TicketsApi - factory interface
 * @export
 */
export const TicketsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TicketsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a single artifact
         * @param {number} id Ticket ID
         * @param {Artifact} artifact Artifact object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArtifact(id: number, artifact: Artifact, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.addArtifact(id, artifact, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add ticket comment
         * @param {number} id Ticket ID
         * @param {CommentForm} comment Ticket comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addComment(id: number, comment: CommentForm, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.addComment(id, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new ticket playbook
         * @param {number} id Ticket ID
         * @param {PlaybookTemplateForm} playbook Ticket playbook object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTicketPlaybook(id: number, playbook: PlaybookTemplateForm, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.addTicketPlaybook(id, playbook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complete ticket playbook task
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {string} taskID Task ID
         * @param {object} data Ticket playbook object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask(id: number, playbookID: string, taskID: string, data: object, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.completeTask(id, playbookID, taskID, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new ticket
         * @param {TicketForm} ticket New ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket(ticket: TicketForm, options?: any): AxiosPromise<TicketResponse> {
            return localVarFp.createTicket(ticket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new tickets in batch
         * @param {Array<TicketForm>} ticket New ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketBatch(ticket: Array<TicketForm>, options?: any): AxiosPromise<void> {
            return localVarFp.createTicketBatch(ticket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an ticket
         * @param {number} id Ticket ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicket(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTicket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enrich a single artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {EnrichmentForm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrichArtifact(id: number, name: string, data: EnrichmentForm, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.enrichArtifact(id, name, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact(id: number, name: string, options?: any): AxiosPromise<Artifact> {
            return localVarFp.getArtifact(id, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single ticket
         * @param {number} id Ticket ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicket(id: number, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.getTicket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link an ticket to an ticket
         * @param {number} id Ticket ID
         * @param {number} linkedID Added ticket ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkTicket(id: number, linkedID: number, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.linkTicket(id, linkedID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tickets
         * @param {string} [type] Ticket Type
         * @param {number} [offset] Offset of the list
         * @param {number} [count] Number of tickets
         * @param {Array<string>} [sort] Sort columns
         * @param {Array<boolean>} [desc] Sort descending
         * @param {string} [query] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTickets(type?: string, offset?: number, count?: number, sort?: Array<string>, desc?: Array<boolean>, query?: string, options?: any): AxiosPromise<TicketList> {
            return localVarFp.listTickets(type, offset, count, sort, desc, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeArtifact(id: number, name: string, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.removeArtifact(id, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Comment will be removed from the ticket.
         * @summary Remove an comment from an ticket
         * @param {number} id Ticket ID
         * @param {number} commentID Comment ID to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeComment(id: number, commentID: number, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.removeComment(id, commentID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an ticket playbook
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTicketPlaybook(id: number, playbookID: string, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.removeTicketPlaybook(id, playbookID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run automation on a single artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {string} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runArtifact(id: number, name: string, automation: string, options?: any): AxiosPromise<void> {
            return localVarFp.runArtifact(id, name, automation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run ticket playbook task
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {string} taskID Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTask(id: number, playbookID: string, taskID: string, options?: any): AxiosPromise<void> {
            return localVarFp.runTask(id, playbookID, taskID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set a single artifact
         * @param {number} id Ticket ID
         * @param {string} name 
         * @param {Artifact} artifact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setArtifact(id: number, name: string, artifact: Artifact, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.setArtifact(id, name, artifact, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set ticket references
         * @param {number} id Ticket ID
         * @param {Array<Reference>} references All ticket references
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReferences(id: number, references: Array<Reference>, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.setReferences(id, references, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set ticket schema
         * @param {number} id Ticket ID
         * @param {string} schema New ticket schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchema(id: number, schema: string, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.setSchema(id, schema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set a ticket playbook task data
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {string} taskID Task ID
         * @param {object} data Task data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTaskData(id: number, playbookID: string, taskID: string, data: object, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.setTaskData(id, playbookID, taskID, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set a ticket playbook task owner
         * @param {number} id Ticket ID
         * @param {string} playbookID Playbook ID
         * @param {string} taskID Task ID
         * @param {string} owner Task owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTaskOwner(id: number, playbookID: string, taskID: string, owner: string, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.setTaskOwner(id, playbookID, taskID, owner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink an ticket to an ticket
         * @param {number} id Ticket ID
         * @param {number} linkedID Added ticket ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkTicket(id: number, linkedID: number, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.unlinkTicket(id, linkedID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing ticket
         * @param {number} id Ticket ID
         * @param {Ticket} ticket Updated ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicket(id: number, ticket: Ticket, options?: any): AxiosPromise<TicketWithTickets> {
            return localVarFp.updateTicket(id, ticket, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TicketsApi - object-oriented interface
 * @export
 * @class TicketsApi
 * @extends {BaseAPI}
 */
export class TicketsApi extends BaseAPI {
    /**
     * 
     * @summary Add a single artifact
     * @param {number} id Ticket ID
     * @param {Artifact} artifact Artifact object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public addArtifact(id: number, artifact: Artifact, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).addArtifact(id, artifact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add ticket comment
     * @param {number} id Ticket ID
     * @param {CommentForm} comment Ticket comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public addComment(id: number, comment: CommentForm, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).addComment(id, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new ticket playbook
     * @param {number} id Ticket ID
     * @param {PlaybookTemplateForm} playbook Ticket playbook object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public addTicketPlaybook(id: number, playbook: PlaybookTemplateForm, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).addTicketPlaybook(id, playbook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complete ticket playbook task
     * @param {number} id Ticket ID
     * @param {string} playbookID Playbook ID
     * @param {string} taskID Task ID
     * @param {object} data Ticket playbook object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public completeTask(id: number, playbookID: string, taskID: string, data: object, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).completeTask(id, playbookID, taskID, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new ticket
     * @param {TicketForm} ticket New ticket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public createTicket(ticket: TicketForm, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).createTicket(ticket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new tickets in batch
     * @param {Array<TicketForm>} ticket New ticket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public createTicketBatch(ticket: Array<TicketForm>, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).createTicketBatch(ticket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an ticket
     * @param {number} id Ticket ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public deleteTicket(id: number, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).deleteTicket(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enrich a single artifact
     * @param {number} id Ticket ID
     * @param {string} name 
     * @param {EnrichmentForm} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public enrichArtifact(id: number, name: string, data: EnrichmentForm, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).enrichArtifact(id, name, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single artifact
     * @param {number} id Ticket ID
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public getArtifact(id: number, name: string, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).getArtifact(id, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single ticket
     * @param {number} id Ticket ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public getTicket(id: number, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).getTicket(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link an ticket to an ticket
     * @param {number} id Ticket ID
     * @param {number} linkedID Added ticket ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public linkTicket(id: number, linkedID: number, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).linkTicket(id, linkedID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tickets
     * @param {string} [type] Ticket Type
     * @param {number} [offset] Offset of the list
     * @param {number} [count] Number of tickets
     * @param {Array<string>} [sort] Sort columns
     * @param {Array<boolean>} [desc] Sort descending
     * @param {string} [query] Search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public listTickets(type?: string, offset?: number, count?: number, sort?: Array<string>, desc?: Array<boolean>, query?: string, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).listTickets(type, offset, count, sort, desc, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an artifact
     * @param {number} id Ticket ID
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public removeArtifact(id: number, name: string, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).removeArtifact(id, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Comment will be removed from the ticket.
     * @summary Remove an comment from an ticket
     * @param {number} id Ticket ID
     * @param {number} commentID Comment ID to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public removeComment(id: number, commentID: number, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).removeComment(id, commentID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an ticket playbook
     * @param {number} id Ticket ID
     * @param {string} playbookID Playbook ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public removeTicketPlaybook(id: number, playbookID: string, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).removeTicketPlaybook(id, playbookID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run automation on a single artifact
     * @param {number} id Ticket ID
     * @param {string} name 
     * @param {string} automation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public runArtifact(id: number, name: string, automation: string, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).runArtifact(id, name, automation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run ticket playbook task
     * @param {number} id Ticket ID
     * @param {string} playbookID Playbook ID
     * @param {string} taskID Task ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public runTask(id: number, playbookID: string, taskID: string, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).runTask(id, playbookID, taskID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set a single artifact
     * @param {number} id Ticket ID
     * @param {string} name 
     * @param {Artifact} artifact 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public setArtifact(id: number, name: string, artifact: Artifact, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).setArtifact(id, name, artifact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set ticket references
     * @param {number} id Ticket ID
     * @param {Array<Reference>} references All ticket references
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public setReferences(id: number, references: Array<Reference>, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).setReferences(id, references, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set ticket schema
     * @param {number} id Ticket ID
     * @param {string} schema New ticket schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public setSchema(id: number, schema: string, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).setSchema(id, schema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set a ticket playbook task data
     * @param {number} id Ticket ID
     * @param {string} playbookID Playbook ID
     * @param {string} taskID Task ID
     * @param {object} data Task data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public setTaskData(id: number, playbookID: string, taskID: string, data: object, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).setTaskData(id, playbookID, taskID, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set a ticket playbook task owner
     * @param {number} id Ticket ID
     * @param {string} playbookID Playbook ID
     * @param {string} taskID Task ID
     * @param {string} owner Task owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public setTaskOwner(id: number, playbookID: string, taskID: string, owner: string, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).setTaskOwner(id, playbookID, taskID, owner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink an ticket to an ticket
     * @param {number} id Ticket ID
     * @param {number} linkedID Added ticket ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public unlinkTicket(id: number, linkedID: number, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).unlinkTicket(id, linkedID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing ticket
     * @param {number} id Ticket ID
     * @param {Ticket} ticket Updated ticket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public updateTicket(id: number, ticket: Ticket, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).updateTicket(id, ticket, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TickettypesApi - axios parameter creator
 * @export
 */
export const TickettypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new tickettype
         * @param {TicketTypeForm} tickettype New tickettype
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketType: async (tickettype: TicketTypeForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tickettype' is not null or undefined
            assertParamExists('createTicketType', 'tickettype', tickettype)
            const localVarPath = `/tickettypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tickettype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a tickettype
         * @param {string} id TicketType ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicketType: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTicketType', 'id', id)
            const localVarPath = `/tickettypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single tickettype
         * @param {string} id TicketType ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketType: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTicketType', 'id', id)
            const localVarPath = `/tickettypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tickettypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTicketTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tickettypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing tickettype
         * @param {string} id TicketType ID
         * @param {TicketTypeForm} tickettype TicketType object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketType: async (id: string, tickettype: TicketTypeForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTicketType', 'id', id)
            // verify required parameter 'tickettype' is not null or undefined
            assertParamExists('updateTicketType', 'tickettype', tickettype)
            const localVarPath = `/tickettypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tickettype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TickettypesApi - functional programming interface
 * @export
 */
export const TickettypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TickettypesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new tickettype
         * @param {TicketTypeForm} tickettype New tickettype
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicketType(tickettype: TicketTypeForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicketType(tickettype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a tickettype
         * @param {string} id TicketType ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTicketType(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTicketType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single tickettype
         * @param {string} id TicketType ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicketType(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List tickettypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTicketTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TicketTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTicketTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing tickettype
         * @param {string} id TicketType ID
         * @param {TicketTypeForm} tickettype TicketType object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTicketType(id: string, tickettype: TicketTypeForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTicketType(id, tickettype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TickettypesApi - factory interface
 * @export
 */
export const TickettypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TickettypesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new tickettype
         * @param {TicketTypeForm} tickettype New tickettype
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketType(tickettype: TicketTypeForm, options?: any): AxiosPromise<TicketTypeResponse> {
            return localVarFp.createTicketType(tickettype, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a tickettype
         * @param {string} id TicketType ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicketType(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTicketType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single tickettype
         * @param {string} id TicketType ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketType(id: string, options?: any): AxiosPromise<TicketTypeResponse> {
            return localVarFp.getTicketType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tickettypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTicketTypes(options?: any): AxiosPromise<Array<TicketTypeResponse>> {
            return localVarFp.listTicketTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing tickettype
         * @param {string} id TicketType ID
         * @param {TicketTypeForm} tickettype TicketType object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketType(id: string, tickettype: TicketTypeForm, options?: any): AxiosPromise<TicketTypeResponse> {
            return localVarFp.updateTicketType(id, tickettype, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TickettypesApi - object-oriented interface
 * @export
 * @class TickettypesApi
 * @extends {BaseAPI}
 */
export class TickettypesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new tickettype
     * @param {TicketTypeForm} tickettype New tickettype
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TickettypesApi
     */
    public createTicketType(tickettype: TicketTypeForm, options?: AxiosRequestConfig) {
        return TickettypesApiFp(this.configuration).createTicketType(tickettype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a tickettype
     * @param {string} id TicketType ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TickettypesApi
     */
    public deleteTicketType(id: string, options?: AxiosRequestConfig) {
        return TickettypesApiFp(this.configuration).deleteTicketType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single tickettype
     * @param {string} id TicketType ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TickettypesApi
     */
    public getTicketType(id: string, options?: AxiosRequestConfig) {
        return TickettypesApiFp(this.configuration).getTicketType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tickettypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TickettypesApi
     */
    public listTicketTypes(options?: AxiosRequestConfig) {
        return TickettypesApiFp(this.configuration).listTicketTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing tickettype
     * @param {string} id TicketType ID
     * @param {TicketTypeForm} tickettype TicketType object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TickettypesApi
     */
    public updateTicketType(id: string, tickettype: TicketTypeForm, options?: AxiosRequestConfig) {
        return TickettypesApiFp(this.configuration).updateTicketType(id, tickettype, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserdataApi - axios parameter creator
 * @export
 */
export const UserdataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/currentuserdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single user data
         * @param {string} id User Data ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserData: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserData', 'id', id)
            const localVarPath = `/userdata/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List userdata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/userdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update current user data
         * @param {UserData} userdata User data object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUserData: async (userdata: UserData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userdata' is not null or undefined
            assertParamExists('updateCurrentUserData', 'userdata', userdata)
            const localVarPath = `/currentuserdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userdata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing user data
         * @param {string} id User Data ID
         * @param {UserData} userdata User data object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserData: async (id: string, userdata: UserData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserData', 'id', id)
            // verify required parameter 'userdata' is not null or undefined
            assertParamExists('updateUserData', 'userdata', userdata)
            const localVarPath = `/userdata/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userdata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserdataApi - functional programming interface
 * @export
 */
export const UserdataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserdataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserData(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single user data
         * @param {string} id User Data ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserData(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List userdata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserData(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDataResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update current user data
         * @param {UserData} userdata User data object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrentUserData(userdata: UserData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrentUserData(userdata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing user data
         * @param {string} id User Data ID
         * @param {UserData} userdata User data object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserData(id: string, userdata: UserData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserData(id, userdata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserdataApi - factory interface
 * @export
 */
export const UserdataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserdataApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserData(options?: any): AxiosPromise<UserDataResponse> {
            return localVarFp.currentUserData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single user data
         * @param {string} id User Data ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserData(id: string, options?: any): AxiosPromise<UserDataResponse> {
            return localVarFp.getUserData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List userdata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserData(options?: any): AxiosPromise<Array<UserDataResponse>> {
            return localVarFp.listUserData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update current user data
         * @param {UserData} userdata User data object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUserData(userdata: UserData, options?: any): AxiosPromise<UserDataResponse> {
            return localVarFp.updateCurrentUserData(userdata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing user data
         * @param {string} id User Data ID
         * @param {UserData} userdata User data object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserData(id: string, userdata: UserData, options?: any): AxiosPromise<UserDataResponse> {
            return localVarFp.updateUserData(id, userdata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserdataApi - object-oriented interface
 * @export
 * @class UserdataApi
 * @extends {BaseAPI}
 */
export class UserdataApi extends BaseAPI {
    /**
     * 
     * @summary Get current user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserdataApi
     */
    public currentUserData(options?: AxiosRequestConfig) {
        return UserdataApiFp(this.configuration).currentUserData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single user data
     * @param {string} id User Data ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserdataApi
     */
    public getUserData(id: string, options?: AxiosRequestConfig) {
        return UserdataApiFp(this.configuration).getUserData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List userdata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserdataApi
     */
    public listUserData(options?: AxiosRequestConfig) {
        return UserdataApiFp(this.configuration).listUserData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update current user data
     * @param {UserData} userdata User data object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserdataApi
     */
    public updateCurrentUserData(userdata: UserData, options?: AxiosRequestConfig) {
        return UserdataApiFp(this.configuration).updateCurrentUserData(userdata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing user data
     * @param {string} id User Data ID
     * @param {UserData} userdata User data object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserdataApi
     */
    public updateUserData(id: string, userdata: UserData, options?: AxiosRequestConfig) {
        return UserdataApiFp(this.configuration).updateUserData(id, userdata, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create user
         * @param {UserForm} user user object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (user: UserForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUser', 'user', user)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/currentuser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user
         * @param {string} id user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single user
         * @param {string} id user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user
         * @param {string} id Template ID
         * @param {UserForm} user user object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, user: UserForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create user
         * @param {UserForm} user user object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(user: UserForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete user
         * @param {string} id user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single user
         * @param {string} id user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user
         * @param {string} id Template ID
         * @param {UserForm} user user object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, user: UserForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create user
         * @param {UserForm} user user object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: UserForm, options?: any): AxiosPromise<NewUserResponse> {
            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUser(options?: any): AxiosPromise<UserResponse> {
            return localVarFp.currentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user
         * @param {string} id user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single user
         * @param {string} id user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: any): AxiosPromise<Array<UserResponse>> {
            return localVarFp.listUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user
         * @param {string} id Template ID
         * @param {UserForm} user user object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, user: UserForm, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.updateUser(id, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Create user
     * @param {UserForm} user user object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(user: UserForm, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public currentUser(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).currentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user
     * @param {string} id user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single user
     * @param {string} id user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user
     * @param {string} id Template ID
     * @param {UserForm} user user object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: string, user: UserForm, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(id, user, options).then((request) => request(this.axios, this.basePath));
    }
}


