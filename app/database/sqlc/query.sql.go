// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const commitSession = `-- name: CommitSession :exec
INSERT OR
REPLACE
INTO sessions (token, data, expiry)
VALUES (?1, ?2, ?3)
`

type CommitSessionParams struct {
	Token  string `json:"token"`
	Data   []byte `json:"data"`
	Expiry int64  `json:"expiry"`
}

func (q *Queries) CommitSession(ctx context.Context, arg CommitSessionParams) error {
	_, err := q.db.ExecContext(ctx, commitSession, arg.Token, arg.Data, arg.Expiry)
	return err
}

const createComment = `-- name: CreateComment :one

INSERT INTO comments (id, author, message, ticket)
VALUES (?1, ?2, ?3, ?4)
RETURNING author, created, id, message, ticket, updated
`

type CreateCommentParams struct {
	ID      string `json:"id"`
	Author  string `json:"author"`
	Message string `json:"message"`
	Ticket  string `json:"ticket"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.ID,
		arg.Author,
		arg.Message,
		arg.Ticket,
	)
	var i Comment
	err := row.Scan(
		&i.Author,
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const createFeature = `-- name: CreateFeature :one

INSERT INTO features (name)
VALUES (?1)
RETURNING created, id, name, updated
`

// ----------------------------------------------------------------
func (q *Queries) CreateFeature(ctx context.Context, name string) (Feature, error) {
	row := q.db.QueryRowContext(ctx, createFeature, name)
	var i Feature
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const createFile = `-- name: CreateFile :one

INSERT INTO files (id, name, blob, size, ticket)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING blob, created, id, name, size, ticket, updated
`

type CreateFileParams struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	Blob   string `json:"blob"`
	Size   int64  `json:"size"`
	Ticket string `json:"ticket"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, createFile,
		arg.ID,
		arg.Name,
		arg.Blob,
		arg.Size,
		arg.Ticket,
	)
	var i File
	err := row.Scan(
		&i.Blob,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Size,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const createLink = `-- name: CreateLink :one

INSERT INTO links (id, name, url, ticket)
VALUES (?1, ?2, ?3, ?4)
RETURNING created, id, name, ticket, updated, url
`

type CreateLinkParams struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	Url    string `json:"url"`
	Ticket string `json:"ticket"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateLink(ctx context.Context, arg CreateLinkParams) (Link, error) {
	row := q.db.QueryRowContext(ctx, createLink,
		arg.ID,
		arg.Name,
		arg.Url,
		arg.Ticket,
	)
	var i Link
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Ticket,
		&i.Updated,
		&i.Url,
	)
	return i, err
}

const createReaction = `-- name: CreateReaction :one

INSERT INTO reactions (id, name, action, actiondata, trigger, triggerdata)
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
RETURNING "action", actiondata, created, id, name, "trigger", triggerdata, updated
`

type CreateReactionParams struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Action      string `json:"action"`
	Actiondata  string `json:"actiondata"`
	Trigger     string `json:"trigger"`
	Triggerdata string `json:"triggerdata"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateReaction(ctx context.Context, arg CreateReactionParams) (Reaction, error) {
	row := q.db.QueryRowContext(ctx, createReaction,
		arg.ID,
		arg.Name,
		arg.Action,
		arg.Actiondata,
		arg.Trigger,
		arg.Triggerdata,
	)
	var i Reaction
	err := row.Scan(
		&i.Action,
		&i.Actiondata,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Trigger,
		&i.Triggerdata,
		&i.Updated,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one

INSERT INTO tasks (id, name, open, owner, ticket)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING created, id, name, open, owner, ticket, updated
`

type CreateTaskParams struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	Open   bool   `json:"open"`
	Owner  string `json:"owner"`
	Ticket string `json:"ticket"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, createTask,
		arg.ID,
		arg.Name,
		arg.Open,
		arg.Owner,
		arg.Ticket,
	)
	var i Task
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const createTicket = `-- name: CreateTicket :one
INSERT INTO tickets (id, name, description, open, owner, resolution, schema, state, type)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)
RETURNING created, description, id, name, open, owner, resolution, schema, state, type, updated
`

type CreateTicketParams struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Open        bool   `json:"open"`
	Owner       string `json:"owner"`
	Resolution  string `json:"resolution"`
	Schema      string `json:"schema"`
	State       string `json:"state"`
	Type        string `json:"type"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, createTicket,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Open,
		arg.Owner,
		arg.Resolution,
		arg.Schema,
		arg.State,
		arg.Type,
	)
	var i Ticket
	err := row.Scan(
		&i.Created,
		&i.Description,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Resolution,
		&i.Schema,
		&i.State,
		&i.Type,
		&i.Updated,
	)
	return i, err
}

const createTimeline = `-- name: CreateTimeline :one

INSERT INTO timeline (id, message, ticket, time)
VALUES (?1, ?2, ?3, ?4)
RETURNING created, id, message, ticket, time, updated
`

type CreateTimelineParams struct {
	ID      string `json:"id"`
	Message string `json:"message"`
	Ticket  string `json:"ticket"`
	Time    string `json:"time"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateTimeline(ctx context.Context, arg CreateTimelineParams) (Timeline, error) {
	row := q.db.QueryRowContext(ctx, createTimeline,
		arg.ID,
		arg.Message,
		arg.Ticket,
		arg.Time,
	)
	var i Timeline
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Time,
		&i.Updated,
	)
	return i, err
}

const createType = `-- name: CreateType :one

INSERT INTO types (id, singular, plural, icon, schema)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING created, icon, id, plural, schema, singular, updated
`

type CreateTypeParams struct {
	ID       string `json:"id"`
	Singular string `json:"singular"`
	Plural   string `json:"plural"`
	Icon     string `json:"icon"`
	Schema   string `json:"schema"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateType(ctx context.Context, arg CreateTypeParams) (Type, error) {
	row := q.db.QueryRowContext(ctx, createType,
		arg.ID,
		arg.Singular,
		arg.Plural,
		arg.Icon,
		arg.Schema,
	)
	var i Type
	err := row.Scan(
		&i.Created,
		&i.Icon,
		&i.ID,
		&i.Plural,
		&i.Schema,
		&i.Singular,
		&i.Updated,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (id, name, email, emailVisibility, username, passwordHash, tokenKey, avatar, verified)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)
RETURNING avatar, created, email, emailvisibility, id, lastloginalertsentat, lastresetsentat, lastverificationsentat, name, passwordhash, tokenkey, updated, username, verified
`

type CreateUserParams struct {
	ID              string `json:"id"`
	Name            string `json:"name"`
	Email           string `json:"email"`
	EmailVisibility bool   `json:"emailVisibility"`
	Username        string `json:"username"`
	PasswordHash    string `json:"passwordHash"`
	TokenKey        string `json:"tokenKey"`
	Avatar          string `json:"avatar"`
	Verified        bool   `json:"verified"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.EmailVisibility,
		arg.Username,
		arg.PasswordHash,
		arg.TokenKey,
		arg.Avatar,
		arg.Verified,
	)
	var i User
	err := row.Scan(
		&i.Avatar,
		&i.Created,
		&i.Email,
		&i.Emailvisibility,
		&i.ID,
		&i.Lastloginalertsentat,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Name,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Updated,
		&i.Username,
		&i.Verified,
	)
	return i, err
}

const createWebhook = `-- name: CreateWebhook :one

INSERT INTO webhooks (id, name, collection, destination)
VALUES (?1, ?2, ?3, ?4)
RETURNING collection, created, destination, id, name, updated
`

type CreateWebhookParams struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Collection  string `json:"collection"`
	Destination string `json:"destination"`
}

// ----------------------------------------------------------------
func (q *Queries) CreateWebhook(ctx context.Context, arg CreateWebhookParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, createWebhook,
		arg.ID,
		arg.Name,
		arg.Collection,
		arg.Destination,
	)
	var i Webhook
	err := row.Scan(
		&i.Collection,
		&i.Created,
		&i.Destination,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE
FROM comments
WHERE id = ?1
`

func (q *Queries) DeleteComment(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteComment, id)
	return err
}

const deleteFeature = `-- name: DeleteFeature :exec
DELETE
FROM features
WHERE id = ?1
`

func (q *Queries) DeleteFeature(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteFeature, id)
	return err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE
FROM files
WHERE id = ?1
`

func (q *Queries) DeleteFile(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteFile, id)
	return err
}

const deleteLink = `-- name: DeleteLink :exec
DELETE
FROM links
WHERE id = ?1
`

func (q *Queries) DeleteLink(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteLink, id)
	return err
}

const deleteReaction = `-- name: DeleteReaction :exec
DELETE
FROM reactions
WHERE id = ?1
`

func (q *Queries) DeleteReaction(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteReaction, id)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE
FROM sessions
WHERE token = ?1
`

func (q *Queries) DeleteSession(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, token)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE
FROM tasks
WHERE id = ?1
`

func (q *Queries) DeleteTask(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTask, id)
	return err
}

const deleteTicket = `-- name: DeleteTicket :exec
DELETE
FROM tickets
WHERE id = ?1
`

func (q *Queries) DeleteTicket(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTicket, id)
	return err
}

const deleteTimeline = `-- name: DeleteTimeline :exec
DELETE
FROM timeline
WHERE id = ?1
`

func (q *Queries) DeleteTimeline(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTimeline, id)
	return err
}

const deleteType = `-- name: DeleteType :exec
DELETE
FROM types
WHERE id = ?1
`

func (q *Queries) DeleteType(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteType, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE
FROM users
WHERE id = ?1
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const deleteWebhook = `-- name: DeleteWebhook :exec
DELETE
FROM webhooks
WHERE id = ?1
`

func (q *Queries) DeleteWebhook(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteWebhook, id)
	return err
}

const findSession = `-- name: FindSession :one

SELECT token, data, expiry
FROM sessions
WHERE token = ?1
`

// ----------------------------------------------------------------
func (q *Queries) FindSession(ctx context.Context, token string) (Session, error) {
	row := q.db.QueryRowContext(ctx, findSession, token)
	var i Session
	err := row.Scan(&i.Token, &i.Data, &i.Expiry)
	return i, err
}

const getComment = `-- name: GetComment :one
SELECT comments.author, comments.created, comments.id, comments.message, comments.ticket, comments.updated, users.name as author_name
FROM comments
         LEFT JOIN users ON users.id = comments.author
WHERE comments.id = ?1
`

type GetCommentRow struct {
	Author     string         `json:"author"`
	Created    string         `json:"created"`
	ID         string         `json:"id"`
	Message    string         `json:"message"`
	Ticket     string         `json:"ticket"`
	Updated    string         `json:"updated"`
	AuthorName sql.NullString `json:"author_name"`
}

func (q *Queries) GetComment(ctx context.Context, id string) (GetCommentRow, error) {
	row := q.db.QueryRowContext(ctx, getComment, id)
	var i GetCommentRow
	err := row.Scan(
		&i.Author,
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Updated,
		&i.AuthorName,
	)
	return i, err
}

const getDashboardCounts = `-- name: GetDashboardCounts :many

SELECT id, count
FROM dashboard_counts
`

// ----------------------------------------------------------------
func (q *Queries) GetDashboardCounts(ctx context.Context) ([]DashboardCount, error) {
	rows, err := q.db.QueryContext(ctx, getDashboardCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DashboardCount
	for rows.Next() {
		var i DashboardCount
		if err := rows.Scan(&i.ID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeature = `-- name: GetFeature :one
SELECT created, id, name, updated
FROM features
WHERE id = ?1
`

func (q *Queries) GetFeature(ctx context.Context, id string) (Feature, error) {
	row := q.db.QueryRowContext(ctx, getFeature, id)
	var i Feature
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const getFile = `-- name: GetFile :one
SELECT blob, created, id, name, size, ticket, updated
FROM files
WHERE id = ?1
`

func (q *Queries) GetFile(ctx context.Context, id string) (File, error) {
	row := q.db.QueryRowContext(ctx, getFile, id)
	var i File
	err := row.Scan(
		&i.Blob,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Size,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const getLink = `-- name: GetLink :one
SELECT created, id, name, ticket, updated, url
FROM links
WHERE id = ?1
`

func (q *Queries) GetLink(ctx context.Context, id string) (Link, error) {
	row := q.db.QueryRowContext(ctx, getLink, id)
	var i Link
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Ticket,
		&i.Updated,
		&i.Url,
	)
	return i, err
}

const getReaction = `-- name: GetReaction :one
SELECT "action", actiondata, created, id, name, "trigger", triggerdata, updated
FROM reactions
WHERE id = ?1
`

func (q *Queries) GetReaction(ctx context.Context, id string) (Reaction, error) {
	row := q.db.QueryRowContext(ctx, getReaction, id)
	var i Reaction
	err := row.Scan(
		&i.Action,
		&i.Actiondata,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Trigger,
		&i.Triggerdata,
		&i.Updated,
	)
	return i, err
}

const getSidebar = `-- name: GetSidebar :many
SELECT id, singular, plural, icon, count
FROM sidebar
`

func (q *Queries) GetSidebar(ctx context.Context) ([]Sidebar, error) {
	rows, err := q.db.QueryContext(ctx, getSidebar)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sidebar
	for rows.Next() {
		var i Sidebar
		if err := rows.Scan(
			&i.ID,
			&i.Singular,
			&i.Plural,
			&i.Icon,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTask = `-- name: GetTask :one
SELECT tasks.created, tasks.id, tasks.name, tasks.open, tasks.owner, tasks.ticket, tasks.updated, users.name as owner_name, tickets.name as ticket_name, tickets.type as ticket_type
FROM tasks
         LEFT JOIN users ON users.id = tasks.owner
         LEFT JOIN tickets ON tickets.id = tasks.ticket
WHERE tasks.id = ?1
`

type GetTaskRow struct {
	Created    string         `json:"created"`
	ID         string         `json:"id"`
	Name       string         `json:"name"`
	Open       bool           `json:"open"`
	Owner      string         `json:"owner"`
	Ticket     string         `json:"ticket"`
	Updated    string         `json:"updated"`
	OwnerName  sql.NullString `json:"owner_name"`
	TicketName sql.NullString `json:"ticket_name"`
	TicketType sql.NullString `json:"ticket_type"`
}

func (q *Queries) GetTask(ctx context.Context, id string) (GetTaskRow, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i GetTaskRow
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Ticket,
		&i.Updated,
		&i.OwnerName,
		&i.TicketName,
		&i.TicketType,
	)
	return i, err
}

const getTimeline = `-- name: GetTimeline :one
SELECT created, id, message, ticket, time, updated
FROM timeline
WHERE id = ?1
`

func (q *Queries) GetTimeline(ctx context.Context, id string) (Timeline, error) {
	row := q.db.QueryRowContext(ctx, getTimeline, id)
	var i Timeline
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Time,
		&i.Updated,
	)
	return i, err
}

const getType = `-- name: GetType :one
SELECT created, icon, id, plural, schema, singular, updated
FROM types
WHERE id = ?1
`

func (q *Queries) GetType(ctx context.Context, id string) (Type, error) {
	row := q.db.QueryRowContext(ctx, getType, id)
	var i Type
	err := row.Scan(
		&i.Created,
		&i.Icon,
		&i.ID,
		&i.Plural,
		&i.Schema,
		&i.Singular,
		&i.Updated,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT avatar, created, email, emailvisibility, id, lastloginalertsentat, lastresetsentat, lastverificationsentat, name, passwordhash, tokenkey, updated, username, verified
FROM users
WHERE id = ?1
`

func (q *Queries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.Avatar,
		&i.Created,
		&i.Email,
		&i.Emailvisibility,
		&i.ID,
		&i.Lastloginalertsentat,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Name,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Updated,
		&i.Username,
		&i.Verified,
	)
	return i, err
}

const getWebhook = `-- name: GetWebhook :one
SELECT collection, created, destination, id, name, updated
FROM webhooks
WHERE id = ?1
`

func (q *Queries) GetWebhook(ctx context.Context, id string) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, getWebhook, id)
	var i Webhook
	err := row.Scan(
		&i.Collection,
		&i.Created,
		&i.Destination,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const listComments = `-- name: ListComments :many
SELECT comments.author, comments.created, comments.id, comments.message, comments.ticket, comments.updated, users.name as author_name, COUNT(*) OVER () as total_count
FROM comments
         LEFT JOIN users ON users.id = comments.author
WHERE ticket = ?1
   OR ?1 = ''
ORDER BY comments.created DESC
LIMIT ?3 OFFSET ?2
`

type ListCommentsParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

type ListCommentsRow struct {
	Author     string         `json:"author"`
	Created    string         `json:"created"`
	ID         string         `json:"id"`
	Message    string         `json:"message"`
	Ticket     string         `json:"ticket"`
	Updated    string         `json:"updated"`
	AuthorName sql.NullString `json:"author_name"`
	TotalCount int64          `json:"total_count"`
}

func (q *Queries) ListComments(ctx context.Context, arg ListCommentsParams) ([]ListCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listComments, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCommentsRow
	for rows.Next() {
		var i ListCommentsRow
		if err := rows.Scan(
			&i.Author,
			&i.Created,
			&i.ID,
			&i.Message,
			&i.Ticket,
			&i.Updated,
			&i.AuthorName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeatures = `-- name: ListFeatures :many
SELECT features.created, features.id, features.name, features.updated, COUNT(*) OVER () as total_count
FROM features
ORDER BY features.created DESC
LIMIT ?2 OFFSET ?1
`

type ListFeaturesParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListFeaturesRow struct {
	Created    string `json:"created"`
	ID         string `json:"id"`
	Name       string `json:"name"`
	Updated    string `json:"updated"`
	TotalCount int64  `json:"total_count"`
}

func (q *Queries) ListFeatures(ctx context.Context, arg ListFeaturesParams) ([]ListFeaturesRow, error) {
	rows, err := q.db.QueryContext(ctx, listFeatures, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeaturesRow
	for rows.Next() {
		var i ListFeaturesRow
		if err := rows.Scan(
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Updated,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFiles = `-- name: ListFiles :many
SELECT files.blob, files.created, files.id, files.name, files.size, files.ticket, files.updated, COUNT(*) OVER () as total_count
FROM files
WHERE ticket = ?1
   OR ?1 = ''
ORDER BY files.created DESC
LIMIT ?3 OFFSET ?2
`

type ListFilesParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

type ListFilesRow struct {
	Blob       string `json:"blob"`
	Created    string `json:"created"`
	ID         string `json:"id"`
	Name       string `json:"name"`
	Size       int64  `json:"size"`
	Ticket     string `json:"ticket"`
	Updated    string `json:"updated"`
	TotalCount int64  `json:"total_count"`
}

func (q *Queries) ListFiles(ctx context.Context, arg ListFilesParams) ([]ListFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listFiles, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFilesRow
	for rows.Next() {
		var i ListFilesRow
		if err := rows.Scan(
			&i.Blob,
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Size,
			&i.Ticket,
			&i.Updated,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinks = `-- name: ListLinks :many
SELECT links.created, links.id, links.name, links.ticket, links.updated, links.url, COUNT(*) OVER () as total_count
FROM links
WHERE ticket = ?1
   OR ?1 = ''
ORDER BY links.created DESC
LIMIT ?3 OFFSET ?2
`

type ListLinksParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

type ListLinksRow struct {
	Created    string `json:"created"`
	ID         string `json:"id"`
	Name       string `json:"name"`
	Ticket     string `json:"ticket"`
	Updated    string `json:"updated"`
	Url        string `json:"url"`
	TotalCount int64  `json:"total_count"`
}

func (q *Queries) ListLinks(ctx context.Context, arg ListLinksParams) ([]ListLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, listLinks, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLinksRow
	for rows.Next() {
		var i ListLinksRow
		if err := rows.Scan(
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Ticket,
			&i.Updated,
			&i.Url,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReactions = `-- name: ListReactions :many
SELECT reactions."action", reactions.actiondata, reactions.created, reactions.id, reactions.name, reactions."trigger", reactions.triggerdata, reactions.updated, COUNT(*) OVER () as total_count
FROM reactions
ORDER BY reactions.created DESC
LIMIT ?2 OFFSET ?1
`

type ListReactionsParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListReactionsRow struct {
	Action      string `json:"action"`
	Actiondata  string `json:"actiondata"`
	Created     string `json:"created"`
	ID          string `json:"id"`
	Name        string `json:"name"`
	Trigger     string `json:"trigger"`
	Triggerdata string `json:"triggerdata"`
	Updated     string `json:"updated"`
	TotalCount  int64  `json:"total_count"`
}

func (q *Queries) ListReactions(ctx context.Context, arg ListReactionsParams) ([]ListReactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listReactions, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListReactionsRow
	for rows.Next() {
		var i ListReactionsRow
		if err := rows.Scan(
			&i.Action,
			&i.Actiondata,
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Trigger,
			&i.Triggerdata,
			&i.Updated,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT tasks.created, tasks.id, tasks.name, tasks.open, tasks.owner, tasks.ticket, tasks.updated, users.name as owner_name, tickets.name as ticket_name, tickets.type as ticket_type, COUNT(*) OVER () as total_count
FROM tasks
         LEFT JOIN users ON users.id = tasks.owner
         LEFT JOIN tickets ON tickets.id = tasks.ticket
WHERE ticket = ?1
   OR ?1 = ''
ORDER BY tasks.created DESC
LIMIT ?3 OFFSET ?2
`

type ListTasksParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

type ListTasksRow struct {
	Created    string         `json:"created"`
	ID         string         `json:"id"`
	Name       string         `json:"name"`
	Open       bool           `json:"open"`
	Owner      string         `json:"owner"`
	Ticket     string         `json:"ticket"`
	Updated    string         `json:"updated"`
	OwnerName  sql.NullString `json:"owner_name"`
	TicketName sql.NullString `json:"ticket_name"`
	TicketType sql.NullString `json:"ticket_type"`
	TotalCount int64          `json:"total_count"`
}

func (q *Queries) ListTasks(ctx context.Context, arg ListTasksParams) ([]ListTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, listTasks, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksRow
	for rows.Next() {
		var i ListTasksRow
		if err := rows.Scan(
			&i.Created,
			&i.ID,
			&i.Name,
			&i.Open,
			&i.Owner,
			&i.Ticket,
			&i.Updated,
			&i.OwnerName,
			&i.TicketName,
			&i.TicketType,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTickets = `-- name: ListTickets :many
SELECT tickets.created, tickets.description, tickets.id, tickets.name, tickets.open, tickets.owner, tickets.resolution, tickets.schema, tickets.state, tickets.type, tickets.updated, users.name as owner_name, types.singular as type_singular, types.plural as type_plural, COUNT(*) OVER () as total_count
FROM tickets
         LEFT JOIN users ON users.id = tickets.owner
         LEFT JOIN types ON types.id = tickets.type
ORDER BY tickets.created DESC
LIMIT ?2 OFFSET ?1
`

type ListTicketsParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListTicketsRow struct {
	Created      string         `json:"created"`
	Description  string         `json:"description"`
	ID           string         `json:"id"`
	Name         string         `json:"name"`
	Open         bool           `json:"open"`
	Owner        string         `json:"owner"`
	Resolution   string         `json:"resolution"`
	Schema       string         `json:"schema"`
	State        string         `json:"state"`
	Type         string         `json:"type"`
	Updated      string         `json:"updated"`
	OwnerName    sql.NullString `json:"owner_name"`
	TypeSingular sql.NullString `json:"type_singular"`
	TypePlural   sql.NullString `json:"type_plural"`
	TotalCount   int64          `json:"total_count"`
}

func (q *Queries) ListTickets(ctx context.Context, arg ListTicketsParams) ([]ListTicketsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTickets, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTicketsRow
	for rows.Next() {
		var i ListTicketsRow
		if err := rows.Scan(
			&i.Created,
			&i.Description,
			&i.ID,
			&i.Name,
			&i.Open,
			&i.Owner,
			&i.Resolution,
			&i.Schema,
			&i.State,
			&i.Type,
			&i.Updated,
			&i.OwnerName,
			&i.TypeSingular,
			&i.TypePlural,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTimeline = `-- name: ListTimeline :many
SELECT timeline.created, timeline.id, timeline.message, timeline.ticket, timeline.time, timeline.updated, COUNT(*) OVER () as total_count
FROM timeline
WHERE ticket = ?1
   OR ?1 = ''
ORDER BY timeline.created DESC
LIMIT ?3 OFFSET ?2
`

type ListTimelineParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

type ListTimelineRow struct {
	Created    string `json:"created"`
	ID         string `json:"id"`
	Message    string `json:"message"`
	Ticket     string `json:"ticket"`
	Time       string `json:"time"`
	Updated    string `json:"updated"`
	TotalCount int64  `json:"total_count"`
}

func (q *Queries) ListTimeline(ctx context.Context, arg ListTimelineParams) ([]ListTimelineRow, error) {
	rows, err := q.db.QueryContext(ctx, listTimeline, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTimelineRow
	for rows.Next() {
		var i ListTimelineRow
		if err := rows.Scan(
			&i.Created,
			&i.ID,
			&i.Message,
			&i.Ticket,
			&i.Time,
			&i.Updated,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTypes = `-- name: ListTypes :many
SELECT types.created, types.icon, types.id, types.plural, types.schema, types.singular, types.updated, COUNT(*) OVER () as total_count
FROM types
ORDER BY created DESC
LIMIT ?2 OFFSET ?1
`

type ListTypesParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListTypesRow struct {
	Created    string `json:"created"`
	Icon       string `json:"icon"`
	ID         string `json:"id"`
	Plural     string `json:"plural"`
	Schema     string `json:"schema"`
	Singular   string `json:"singular"`
	Updated    string `json:"updated"`
	TotalCount int64  `json:"total_count"`
}

func (q *Queries) ListTypes(ctx context.Context, arg ListTypesParams) ([]ListTypesRow, error) {
	rows, err := q.db.QueryContext(ctx, listTypes, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTypesRow
	for rows.Next() {
		var i ListTypesRow
		if err := rows.Scan(
			&i.Created,
			&i.Icon,
			&i.ID,
			&i.Plural,
			&i.Schema,
			&i.Singular,
			&i.Updated,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT users.avatar, users.created, users.email, users.emailvisibility, users.id, users.lastloginalertsentat, users.lastresetsentat, users.lastverificationsentat, users.name, users.passwordhash, users.tokenkey, users.updated, users.username, users.verified, COUNT(*) OVER () as total_count
FROM users
ORDER BY users.created DESC
LIMIT ?2 OFFSET ?1
`

type ListUsersParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListUsersRow struct {
	Avatar                 string `json:"avatar"`
	Created                string `json:"created"`
	Email                  string `json:"email"`
	Emailvisibility        bool   `json:"emailvisibility"`
	ID                     string `json:"id"`
	Lastloginalertsentat   string `json:"lastloginalertsentat"`
	Lastresetsentat        string `json:"lastresetsentat"`
	Lastverificationsentat string `json:"lastverificationsentat"`
	Name                   string `json:"name"`
	Passwordhash           string `json:"passwordhash"`
	Tokenkey               string `json:"tokenkey"`
	Updated                string `json:"updated"`
	Username               string `json:"username"`
	Verified               bool   `json:"verified"`
	TotalCount             int64  `json:"total_count"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.Avatar,
			&i.Created,
			&i.Email,
			&i.Emailvisibility,
			&i.ID,
			&i.Lastloginalertsentat,
			&i.Lastresetsentat,
			&i.Lastverificationsentat,
			&i.Name,
			&i.Passwordhash,
			&i.Tokenkey,
			&i.Updated,
			&i.Username,
			&i.Verified,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooks = `-- name: ListWebhooks :many
SELECT webhooks.collection, webhooks.created, webhooks.destination, webhooks.id, webhooks.name, webhooks.updated, COUNT(*) OVER () as total_count
FROM webhooks
ORDER BY created DESC
LIMIT ?2 OFFSET ?1
`

type ListWebhooksParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListWebhooksRow struct {
	Collection  string `json:"collection"`
	Created     string `json:"created"`
	Destination string `json:"destination"`
	ID          string `json:"id"`
	Name        string `json:"name"`
	Updated     string `json:"updated"`
	TotalCount  int64  `json:"total_count"`
}

func (q *Queries) ListWebhooks(ctx context.Context, arg ListWebhooksParams) ([]ListWebhooksRow, error) {
	rows, err := q.db.QueryContext(ctx, listWebhooks, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWebhooksRow
	for rows.Next() {
		var i ListWebhooksRow
		if err := rows.Scan(
			&i.Collection,
			&i.Created,
			&i.Destination,
			&i.ID,
			&i.Name,
			&i.Updated,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTickets = `-- name: SearchTickets :many
SELECT id,
       name,
       created,
       description,
       open,
       type,
       state,
       owner_name,
       COUNT(*) OVER () as total_count
FROM ticket_search
WHERE (?1 = '' OR (name LIKE '%' || ?1 || '%'
   OR description LIKE '%' || ?1 || '%'
   OR comment_messages LIKE '%' || ?1 || '%'
   OR file_names LIKE '%' || ?1 || '%'
   OR link_names LIKE '%' || ?1 || '%'
   OR link_urls LIKE '%' || ?1 || '%'
   OR task_names LIKE '%' || ?1 || '%'
   OR timeline_messages LIKE '%' || ?1 || '%'))
    AND (?2 IS NULL OR type = ?2)
    AND (?3 IS NULL OR open = ?3)
LIMIT ?5 OFFSET ?4
`

type SearchTicketsParams struct {
	Query  interface{} `json:"query"`
	Type   interface{} `json:"type"`
	Open   interface{} `json:"open"`
	Offset int64       `json:"offset"`
	Limit  int64       `json:"limit"`
}

type SearchTicketsRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Created     string         `json:"created"`
	Description string         `json:"description"`
	Open        bool           `json:"open"`
	Type        string         `json:"type"`
	State       string         `json:"state"`
	OwnerName   sql.NullString `json:"owner_name"`
	TotalCount  int64          `json:"total_count"`
}

func (q *Queries) SearchTickets(ctx context.Context, arg SearchTicketsParams) ([]SearchTicketsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchTickets,
		arg.Query,
		arg.Type,
		arg.Open,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchTicketsRow
	for rows.Next() {
		var i SearchTicketsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Description,
			&i.Open,
			&i.Type,
			&i.State,
			&i.OwnerName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ticket = `-- name: Ticket :one
SELECT tickets.created, tickets.description, tickets.id, tickets.name, tickets.open, tickets.owner, tickets.resolution, tickets.schema, tickets.state, tickets.type, tickets.updated, users.name as owner_name, types.singular as type_singular, types.plural as type_plural
FROM tickets
         LEFT JOIN users ON users.id = tickets.owner
         LEFT JOIN types ON types.id = tickets.type
WHERE tickets.id = ?1
`

type TicketRow struct {
	Created      string         `json:"created"`
	Description  string         `json:"description"`
	ID           string         `json:"id"`
	Name         string         `json:"name"`
	Open         bool           `json:"open"`
	Owner        string         `json:"owner"`
	Resolution   string         `json:"resolution"`
	Schema       string         `json:"schema"`
	State        string         `json:"state"`
	Type         string         `json:"type"`
	Updated      string         `json:"updated"`
	OwnerName    sql.NullString `json:"owner_name"`
	TypeSingular sql.NullString `json:"type_singular"`
	TypePlural   sql.NullString `json:"type_plural"`
}

func (q *Queries) Ticket(ctx context.Context, id string) (TicketRow, error) {
	row := q.db.QueryRowContext(ctx, ticket, id)
	var i TicketRow
	err := row.Scan(
		&i.Created,
		&i.Description,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Resolution,
		&i.Schema,
		&i.State,
		&i.Type,
		&i.Updated,
		&i.OwnerName,
		&i.TypeSingular,
		&i.TypePlural,
	)
	return i, err
}

const updateComment = `-- name: UpdateComment :one
UPDATE comments
SET message = coalesce(?1, message)
WHERE id = ?2
RETURNING author, created, id, message, ticket, updated
`

type UpdateCommentParams struct {
	Message sql.NullString `json:"message"`
	ID      string         `json:"id"`
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, updateComment, arg.Message, arg.ID)
	var i Comment
	err := row.Scan(
		&i.Author,
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const updateFeature = `-- name: UpdateFeature :one
UPDATE features
SET name = coalesce(?1, name)
WHERE id = ?2
RETURNING created, id, name, updated
`

type UpdateFeatureParams struct {
	Name sql.NullString `json:"name"`
	ID   string         `json:"id"`
}

func (q *Queries) UpdateFeature(ctx context.Context, arg UpdateFeatureParams) (Feature, error) {
	row := q.db.QueryRowContext(ctx, updateFeature, arg.Name, arg.ID)
	var i Feature
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const updateFile = `-- name: UpdateFile :one
UPDATE files
SET name = coalesce(?1, name),
    blob = coalesce(?2, blob),
    size = coalesce(?3, size)
WHERE id = ?4
RETURNING blob, created, id, name, size, ticket, updated
`

type UpdateFileParams struct {
	Name sql.NullString `json:"name"`
	Blob sql.NullString `json:"blob"`
	Size sql.NullInt64  `json:"size"`
	ID   string         `json:"id"`
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, updateFile,
		arg.Name,
		arg.Blob,
		arg.Size,
		arg.ID,
	)
	var i File
	err := row.Scan(
		&i.Blob,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Size,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const updateLink = `-- name: UpdateLink :one
UPDATE links
SET name = coalesce(?1, name),
    url  = coalesce(?2, url)
WHERE id = ?3
RETURNING created, id, name, ticket, updated, url
`

type UpdateLinkParams struct {
	Name sql.NullString `json:"name"`
	Url  sql.NullString `json:"url"`
	ID   string         `json:"id"`
}

func (q *Queries) UpdateLink(ctx context.Context, arg UpdateLinkParams) (Link, error) {
	row := q.db.QueryRowContext(ctx, updateLink, arg.Name, arg.Url, arg.ID)
	var i Link
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Ticket,
		&i.Updated,
		&i.Url,
	)
	return i, err
}

const updateReaction = `-- name: UpdateReaction :one
UPDATE reactions
SET name        = coalesce(?1, name),
    action      = coalesce(?2, action),
    actiondata  = coalesce(?3, actiondata),
    trigger     = coalesce(?4, trigger),
    triggerdata = coalesce(?5, triggerdata)
WHERE id = ?6
RETURNING "action", actiondata, created, id, name, "trigger", triggerdata, updated
`

type UpdateReactionParams struct {
	Name        sql.NullString `json:"name"`
	Action      sql.NullString `json:"action"`
	Actiondata  string         `json:"actiondata"`
	Trigger     sql.NullString `json:"trigger"`
	Triggerdata string         `json:"triggerdata"`
	ID          string         `json:"id"`
}

func (q *Queries) UpdateReaction(ctx context.Context, arg UpdateReactionParams) (Reaction, error) {
	row := q.db.QueryRowContext(ctx, updateReaction,
		arg.Name,
		arg.Action,
		arg.Actiondata,
		arg.Trigger,
		arg.Triggerdata,
		arg.ID,
	)
	var i Reaction
	err := row.Scan(
		&i.Action,
		&i.Actiondata,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Trigger,
		&i.Triggerdata,
		&i.Updated,
	)
	return i, err
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks
SET name  = coalesce(?1, name),
    open  = coalesce(?2, open),
    owner = coalesce(?3, owner)
WHERE id = ?4
RETURNING created, id, name, open, owner, ticket, updated
`

type UpdateTaskParams struct {
	Name  sql.NullString `json:"name"`
	Open  sql.NullBool   `json:"open"`
	Owner sql.NullString `json:"owner"`
	ID    string         `json:"id"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, updateTask,
		arg.Name,
		arg.Open,
		arg.Owner,
		arg.ID,
	)
	var i Task
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const updateTicket = `-- name: UpdateTicket :one
UPDATE tickets
SET name        = coalesce(?1, name),
    description = coalesce(?2, description),
    open        = coalesce(?3, open),
    owner       = coalesce(?4, owner),
    resolution  = coalesce(?5, resolution),
    schema      = coalesce(?6, schema),
    state       = coalesce(?7, state),
    type        = coalesce(?8, type)
WHERE id = ?9
RETURNING created, description, id, name, open, owner, resolution, schema, state, type, updated
`

type UpdateTicketParams struct {
	Name        sql.NullString `json:"name"`
	Description sql.NullString `json:"description"`
	Open        sql.NullBool   `json:"open"`
	Owner       sql.NullString `json:"owner"`
	Resolution  sql.NullString `json:"resolution"`
	Schema      string         `json:"schema"`
	State       string         `json:"state"`
	Type        sql.NullString `json:"type"`
	ID          string         `json:"id"`
}

func (q *Queries) UpdateTicket(ctx context.Context, arg UpdateTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, updateTicket,
		arg.Name,
		arg.Description,
		arg.Open,
		arg.Owner,
		arg.Resolution,
		arg.Schema,
		arg.State,
		arg.Type,
		arg.ID,
	)
	var i Ticket
	err := row.Scan(
		&i.Created,
		&i.Description,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Resolution,
		&i.Schema,
		&i.State,
		&i.Type,
		&i.Updated,
	)
	return i, err
}

const updateTimeline = `-- name: UpdateTimeline :one
UPDATE timeline
SET message = coalesce(?1, message),
    time    = coalesce(?2, time)
WHERE id = ?3
RETURNING created, id, message, ticket, time, updated
`

type UpdateTimelineParams struct {
	Message sql.NullString `json:"message"`
	Time    sql.NullString `json:"time"`
	ID      string         `json:"id"`
}

func (q *Queries) UpdateTimeline(ctx context.Context, arg UpdateTimelineParams) (Timeline, error) {
	row := q.db.QueryRowContext(ctx, updateTimeline, arg.Message, arg.Time, arg.ID)
	var i Timeline
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Time,
		&i.Updated,
	)
	return i, err
}

const updateType = `-- name: UpdateType :one
UPDATE types
SET singular = coalesce(?1, singular),
    plural   = coalesce(?2, plural),
    icon     = coalesce(?3, icon),
    schema   = coalesce(?4, schema)
WHERE id = ?5
RETURNING created, icon, id, plural, schema, singular, updated
`

type UpdateTypeParams struct {
	Singular sql.NullString `json:"singular"`
	Plural   sql.NullString `json:"plural"`
	Icon     sql.NullString `json:"icon"`
	Schema   string         `json:"schema"`
	ID       string         `json:"id"`
}

func (q *Queries) UpdateType(ctx context.Context, arg UpdateTypeParams) (Type, error) {
	row := q.db.QueryRowContext(ctx, updateType,
		arg.Singular,
		arg.Plural,
		arg.Icon,
		arg.Schema,
		arg.ID,
	)
	var i Type
	err := row.Scan(
		&i.Created,
		&i.Icon,
		&i.ID,
		&i.Plural,
		&i.Schema,
		&i.Singular,
		&i.Updated,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET name                   = coalesce(?1, name),
    email                  = coalesce(?2, email),
    emailVisibility        = coalesce(?3, emailVisibility),
    username               = coalesce(?4, username),
    passwordHash           = coalesce(?5, passwordHash),
    tokenKey               = coalesce(?6, tokenKey),
    avatar                 = coalesce(?7, avatar),
    verified               = coalesce(?8, verified)
WHERE id = ?9
RETURNING avatar, created, email, emailvisibility, id, lastloginalertsentat, lastresetsentat, lastverificationsentat, name, passwordhash, tokenkey, updated, username, verified
`

type UpdateUserParams struct {
	Name            sql.NullString `json:"name"`
	Email           sql.NullString `json:"email"`
	EmailVisibility sql.NullBool   `json:"emailVisibility"`
	Username        sql.NullString `json:"username"`
	PasswordHash    sql.NullString `json:"passwordHash"`
	TokenKey        sql.NullString `json:"tokenKey"`
	Avatar          sql.NullString `json:"avatar"`
	Verified        sql.NullBool   `json:"verified"`
	ID              string         `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Name,
		arg.Email,
		arg.EmailVisibility,
		arg.Username,
		arg.PasswordHash,
		arg.TokenKey,
		arg.Avatar,
		arg.Verified,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.Avatar,
		&i.Created,
		&i.Email,
		&i.Emailvisibility,
		&i.ID,
		&i.Lastloginalertsentat,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Name,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Updated,
		&i.Username,
		&i.Verified,
	)
	return i, err
}

const updateWebhook = `-- name: UpdateWebhook :one
UPDATE webhooks
SET name        = coalesce(?1, name),
    collection  = coalesce(?2, collection),
    destination = coalesce(?3, destination)
WHERE id = ?4
RETURNING collection, created, destination, id, name, updated
`

type UpdateWebhookParams struct {
	Name        sql.NullString `json:"name"`
	Collection  sql.NullString `json:"collection"`
	Destination sql.NullString `json:"destination"`
	ID          string         `json:"id"`
}

func (q *Queries) UpdateWebhook(ctx context.Context, arg UpdateWebhookParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, updateWebhook,
		arg.Name,
		arg.Collection,
		arg.Destination,
		arg.ID,
	)
	var i Webhook
	err := row.Scan(
		&i.Collection,
		&i.Created,
		&i.Destination,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const userByEmail = `-- name: UserByEmail :one
SELECT avatar, created, email, emailvisibility, id, lastloginalertsentat, lastresetsentat, lastverificationsentat, name, passwordhash, tokenkey, updated, username, verified
FROM users
WHERE email = ?1
`

func (q *Queries) UserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, userByEmail, email)
	var i User
	err := row.Scan(
		&i.Avatar,
		&i.Created,
		&i.Email,
		&i.Emailvisibility,
		&i.ID,
		&i.Lastloginalertsentat,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Name,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Updated,
		&i.Username,
		&i.Verified,
	)
	return i, err
}

const userByUserName = `-- name: UserByUserName :one
SELECT avatar, created, email, emailvisibility, id, lastloginalertsentat, lastresetsentat, lastverificationsentat, name, passwordhash, tokenkey, updated, username, verified
FROM users
WHERE username = ?1
`

func (q *Queries) UserByUserName(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, userByUserName, username)
	var i User
	err := row.Scan(
		&i.Avatar,
		&i.Created,
		&i.Email,
		&i.Emailvisibility,
		&i.ID,
		&i.Lastloginalertsentat,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Name,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Updated,
		&i.Username,
		&i.Verified,
	)
	return i, err
}
