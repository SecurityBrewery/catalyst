// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: write.sql

package sqlc

import (
	"context"
	"database/sql"
)

const assignGroupToUser = `-- name: AssignGroupToUser :exec
INSERT INTO user_groups (user_id, group_id)
VALUES (?1, ?2)
`

type AssignGroupToUserParams struct {
	UserID  string `json:"user_id"`
	GroupID string `json:"group_id"`
}

func (q *WriteQueries) AssignGroupToUser(ctx context.Context, arg AssignGroupToUserParams) error {
	_, err := q.db.ExecContext(ctx, assignGroupToUser, arg.UserID, arg.GroupID)
	return err
}

const assignParentGroup = `-- name: AssignParentGroup :exec
INSERT INTO group_inheritance (parent_group_id, child_group_id)
VALUES (?1, ?2)
`

type AssignParentGroupParams struct {
	ParentGroupID string `json:"parent_group_id"`
	ChildGroupID  string `json:"child_group_id"`
}

func (q *WriteQueries) AssignParentGroup(ctx context.Context, arg AssignParentGroupParams) error {
	_, err := q.db.ExecContext(ctx, assignParentGroup, arg.ParentGroupID, arg.ChildGroupID)
	return err
}

const createComment = `-- name: CreateComment :one
INSERT INTO comments (author, message, ticket)
VALUES (?1, ?2, ?3)
RETURNING author, created, id, message, ticket, updated
`

type CreateCommentParams struct {
	Author  string `json:"author"`
	Message string `json:"message"`
	Ticket  string `json:"ticket"`
}

func (q *WriteQueries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, createComment, arg.Author, arg.Message, arg.Ticket)
	var i Comment
	err := row.Scan(
		&i.Author,
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const createFeature = `-- name: CreateFeature :one

INSERT INTO features (name)
VALUES (?1)
RETURNING created, id, name, updated
`

// ----------------------------------------------------------------
func (q *WriteQueries) CreateFeature(ctx context.Context, name string) (Feature, error) {
	row := q.db.QueryRowContext(ctx, createFeature, name)
	var i Feature
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (name, blob, size, ticket)
VALUES (?1, ?2, ?3, ?4)
RETURNING blob, created, id, name, size, ticket, updated
`

type CreateFileParams struct {
	Name   string  `json:"name"`
	Blob   string  `json:"blob"`
	Size   float64 `json:"size"`
	Ticket string  `json:"ticket"`
}

func (q *WriteQueries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, createFile,
		arg.Name,
		arg.Blob,
		arg.Size,
		arg.Ticket,
	)
	var i File
	err := row.Scan(
		&i.Blob,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Size,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO groups (name, permissions)
VALUES (?1, ?2)
RETURNING id, name, permissions, created, updated
`

type CreateGroupParams struct {
	Name        string `json:"name"`
	Permissions string `json:"permissions"`
}

func (q *WriteQueries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup, arg.Name, arg.Permissions)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Permissions,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const createLink = `-- name: CreateLink :one
INSERT INTO links (name, url, ticket)
VALUES (?1, ?2, ?3)
RETURNING created, id, name, ticket, updated, url
`

type CreateLinkParams struct {
	Name   string `json:"name"`
	Url    string `json:"url"`
	Ticket string `json:"ticket"`
}

func (q *WriteQueries) CreateLink(ctx context.Context, arg CreateLinkParams) (Link, error) {
	row := q.db.QueryRowContext(ctx, createLink, arg.Name, arg.Url, arg.Ticket)
	var i Link
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Ticket,
		&i.Updated,
		&i.Url,
	)
	return i, err
}

const createParam = `-- name: CreateParam :exec
INSERT INTO _params (id, key, value)
VALUES (?1, ?2, ?3)
RETURNING id, "key", value, created, updated
`

type CreateParamParams struct {
	ID    string `json:"id"`
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (q *WriteQueries) CreateParam(ctx context.Context, arg CreateParamParams) error {
	_, err := q.db.ExecContext(ctx, createParam, arg.ID, arg.Key, arg.Value)
	return err
}

const createReaction = `-- name: CreateReaction :one
INSERT INTO reactions (name, action, actiondata, trigger, triggerdata)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING "action", actiondata, created, id, name, "trigger", triggerdata, updated
`

type CreateReactionParams struct {
	Name        string `json:"name"`
	Action      string `json:"action"`
	Actiondata  string `json:"actiondata"`
	Trigger     string `json:"trigger"`
	Triggerdata string `json:"triggerdata"`
}

func (q *WriteQueries) CreateReaction(ctx context.Context, arg CreateReactionParams) (Reaction, error) {
	row := q.db.QueryRowContext(ctx, createReaction,
		arg.Name,
		arg.Action,
		arg.Actiondata,
		arg.Trigger,
		arg.Triggerdata,
	)
	var i Reaction
	err := row.Scan(
		&i.Action,
		&i.Actiondata,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Trigger,
		&i.Triggerdata,
		&i.Updated,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (name, open, owner, ticket)
VALUES (?1, ?2, ?3, ?4)
RETURNING created, id, name, open, owner, ticket, updated
`

type CreateTaskParams struct {
	Name   string `json:"name"`
	Open   bool   `json:"open"`
	Owner  string `json:"owner"`
	Ticket string `json:"ticket"`
}

func (q *WriteQueries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, createTask,
		arg.Name,
		arg.Open,
		arg.Owner,
		arg.Ticket,
	)
	var i Task
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const createTicket = `-- name: CreateTicket :one
INSERT INTO tickets (name, description, open, owner, resolution, schema, state, type)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)
RETURNING created, description, id, name, open, owner, resolution, schema, state, type, updated
`

type CreateTicketParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Open        bool   `json:"open"`
	Owner       string `json:"owner"`
	Resolution  string `json:"resolution"`
	Schema      string `json:"schema"`
	State       string `json:"state"`
	Type        string `json:"type"`
}

func (q *WriteQueries) CreateTicket(ctx context.Context, arg CreateTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, createTicket,
		arg.Name,
		arg.Description,
		arg.Open,
		arg.Owner,
		arg.Resolution,
		arg.Schema,
		arg.State,
		arg.Type,
	)
	var i Ticket
	err := row.Scan(
		&i.Created,
		&i.Description,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Resolution,
		&i.Schema,
		&i.State,
		&i.Type,
		&i.Updated,
	)
	return i, err
}

const createTimeline = `-- name: CreateTimeline :one
INSERT INTO timeline (message, ticket, time)
VALUES (?1, ?2, ?3)
RETURNING created, id, message, ticket, time, updated
`

type CreateTimelineParams struct {
	Message string `json:"message"`
	Ticket  string `json:"ticket"`
	Time    string `json:"time"`
}

func (q *WriteQueries) CreateTimeline(ctx context.Context, arg CreateTimelineParams) (Timeline, error) {
	row := q.db.QueryRowContext(ctx, createTimeline, arg.Message, arg.Ticket, arg.Time)
	var i Timeline
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Time,
		&i.Updated,
	)
	return i, err
}

const createType = `-- name: CreateType :one
INSERT INTO types (singular, plural, icon, schema)
VALUES (?1, ?2, ?3, ?4)
RETURNING created, icon, id, plural, schema, singular, updated
`

type CreateTypeParams struct {
	Singular string `json:"singular"`
	Plural   string `json:"plural"`
	Icon     string `json:"icon"`
	Schema   string `json:"schema"`
}

func (q *WriteQueries) CreateType(ctx context.Context, arg CreateTypeParams) (Type, error) {
	row := q.db.QueryRowContext(ctx, createType,
		arg.Singular,
		arg.Plural,
		arg.Icon,
		arg.Schema,
	)
	var i Type
	err := row.Scan(
		&i.Created,
		&i.Icon,
		&i.ID,
		&i.Plural,
		&i.Schema,
		&i.Singular,
		&i.Updated,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (name, email, username, passwordHash, tokenKey, avatar, verified)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)
RETURNING avatar, created, email, id, lastresetsentat, lastverificationsentat, name, passwordhash, tokenkey, updated, username, verified
`

type CreateUserParams struct {
	Name         string `json:"name"`
	Email        string `json:"email"`
	Username     string `json:"username"`
	PasswordHash string `json:"passwordHash"`
	TokenKey     string `json:"tokenKey"`
	Avatar       string `json:"avatar"`
	Verified     bool   `json:"verified"`
}

func (q *WriteQueries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Name,
		arg.Email,
		arg.Username,
		arg.PasswordHash,
		arg.TokenKey,
		arg.Avatar,
		arg.Verified,
	)
	var i User
	err := row.Scan(
		&i.Avatar,
		&i.Created,
		&i.Email,
		&i.ID,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Name,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Updated,
		&i.Username,
		&i.Verified,
	)
	return i, err
}

const createWebhook = `-- name: CreateWebhook :one
INSERT INTO webhooks (name, collection, destination)
VALUES (?1, ?2, ?3)
RETURNING collection, created, destination, id, name, updated
`

type CreateWebhookParams struct {
	Name        string `json:"name"`
	Collection  string `json:"collection"`
	Destination string `json:"destination"`
}

func (q *WriteQueries) CreateWebhook(ctx context.Context, arg CreateWebhookParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, createWebhook, arg.Name, arg.Collection, arg.Destination)
	var i Webhook
	err := row.Scan(
		&i.Collection,
		&i.Created,
		&i.Destination,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE
FROM comments
WHERE id = ?1
`

func (q *WriteQueries) DeleteComment(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteComment, id)
	return err
}

const deleteFeature = `-- name: DeleteFeature :exec
DELETE
FROM features
WHERE id = ?1
`

func (q *WriteQueries) DeleteFeature(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteFeature, id)
	return err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE
FROM files
WHERE id = ?1
`

func (q *WriteQueries) DeleteFile(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteFile, id)
	return err
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE
FROM groups
WHERE id = ?1
`

func (q *WriteQueries) DeleteGroup(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteGroup, id)
	return err
}

const deleteLink = `-- name: DeleteLink :exec
DELETE
FROM links
WHERE id = ?1
`

func (q *WriteQueries) DeleteLink(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteLink, id)
	return err
}

const deleteReaction = `-- name: DeleteReaction :exec
DELETE
FROM reactions
WHERE id = ?1
`

func (q *WriteQueries) DeleteReaction(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteReaction, id)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE
FROM tasks
WHERE id = ?1
`

func (q *WriteQueries) DeleteTask(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTask, id)
	return err
}

const deleteTicket = `-- name: DeleteTicket :exec
DELETE
FROM tickets
WHERE id = ?1
`

func (q *WriteQueries) DeleteTicket(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTicket, id)
	return err
}

const deleteTimeline = `-- name: DeleteTimeline :exec
DELETE
FROM timeline
WHERE id = ?1
`

func (q *WriteQueries) DeleteTimeline(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTimeline, id)
	return err
}

const deleteType = `-- name: DeleteType :exec
DELETE
FROM types
WHERE id = ?1
`

func (q *WriteQueries) DeleteType(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteType, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE
FROM users
WHERE id = ?1
  AND id != 'system'
`

func (q *WriteQueries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const deleteWebhook = `-- name: DeleteWebhook :exec
DELETE
FROM webhooks
WHERE id = ?1
`

func (q *WriteQueries) DeleteWebhook(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteWebhook, id)
	return err
}

const insertComment = `-- name: InsertComment :one

INSERT INTO comments (id, author, message, ticket, created, updated)
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
RETURNING author, created, id, message, ticket, updated
`

type InsertCommentParams struct {
	ID      string `json:"id"`
	Author  string `json:"author"`
	Message string `json:"message"`
	Ticket  string `json:"ticket"`
	Created string `json:"created"`
	Updated string `json:"updated"`
}

// ----------------------------------------------------------------
func (q *WriteQueries) InsertComment(ctx context.Context, arg InsertCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, insertComment,
		arg.ID,
		arg.Author,
		arg.Message,
		arg.Ticket,
		arg.Created,
		arg.Updated,
	)
	var i Comment
	err := row.Scan(
		&i.Author,
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const insertFile = `-- name: InsertFile :one

INSERT INTO files (id, name, blob, size, ticket, created, updated)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)
RETURNING blob, created, id, name, size, ticket, updated
`

type InsertFileParams struct {
	ID      string  `json:"id"`
	Name    string  `json:"name"`
	Blob    string  `json:"blob"`
	Size    float64 `json:"size"`
	Ticket  string  `json:"ticket"`
	Created string  `json:"created"`
	Updated string  `json:"updated"`
}

// ----------------------------------------------------------------
func (q *WriteQueries) InsertFile(ctx context.Context, arg InsertFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, insertFile,
		arg.ID,
		arg.Name,
		arg.Blob,
		arg.Size,
		arg.Ticket,
		arg.Created,
		arg.Updated,
	)
	var i File
	err := row.Scan(
		&i.Blob,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Size,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const insertGroup = `-- name: InsertGroup :one

INSERT INTO groups (id, name, permissions, created, updated)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING id, name, permissions, created, updated
`

type InsertGroupParams struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Permissions string `json:"permissions"`
	Created     string `json:"created"`
	Updated     string `json:"updated"`
}

// ----------------------------------------------------------------
func (q *WriteQueries) InsertGroup(ctx context.Context, arg InsertGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, insertGroup,
		arg.ID,
		arg.Name,
		arg.Permissions,
		arg.Created,
		arg.Updated,
	)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Permissions,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const insertLink = `-- name: InsertLink :one

INSERT INTO links (id, name, url, ticket, created, updated)
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
RETURNING created, id, name, ticket, updated, url
`

type InsertLinkParams struct {
	ID      string `json:"id"`
	Name    string `json:"name"`
	Url     string `json:"url"`
	Ticket  string `json:"ticket"`
	Created string `json:"created"`
	Updated string `json:"updated"`
}

// ----------------------------------------------------------------
func (q *WriteQueries) InsertLink(ctx context.Context, arg InsertLinkParams) (Link, error) {
	row := q.db.QueryRowContext(ctx, insertLink,
		arg.ID,
		arg.Name,
		arg.Url,
		arg.Ticket,
		arg.Created,
		arg.Updated,
	)
	var i Link
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Ticket,
		&i.Updated,
		&i.Url,
	)
	return i, err
}

const insertReaction = `-- name: InsertReaction :one

INSERT INTO reactions (id, name, action, actiondata, trigger, triggerdata, created, updated)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)
RETURNING "action", actiondata, created, id, name, "trigger", triggerdata, updated
`

type InsertReactionParams struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Action      string `json:"action"`
	Actiondata  string `json:"actiondata"`
	Trigger     string `json:"trigger"`
	Triggerdata string `json:"triggerdata"`
	Created     string `json:"created"`
	Updated     string `json:"updated"`
}

// ----------------------------------------------------------------
func (q *WriteQueries) InsertReaction(ctx context.Context, arg InsertReactionParams) (Reaction, error) {
	row := q.db.QueryRowContext(ctx, insertReaction,
		arg.ID,
		arg.Name,
		arg.Action,
		arg.Actiondata,
		arg.Trigger,
		arg.Triggerdata,
		arg.Created,
		arg.Updated,
	)
	var i Reaction
	err := row.Scan(
		&i.Action,
		&i.Actiondata,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Trigger,
		&i.Triggerdata,
		&i.Updated,
	)
	return i, err
}

const insertTask = `-- name: InsertTask :one

INSERT INTO tasks (id, name, open, owner, ticket, created, updated)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)
RETURNING created, id, name, open, owner, ticket, updated
`

type InsertTaskParams struct {
	ID      string `json:"id"`
	Name    string `json:"name"`
	Open    bool   `json:"open"`
	Owner   string `json:"owner"`
	Ticket  string `json:"ticket"`
	Created string `json:"created"`
	Updated string `json:"updated"`
}

// ----------------------------------------------------------------
func (q *WriteQueries) InsertTask(ctx context.Context, arg InsertTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, insertTask,
		arg.ID,
		arg.Name,
		arg.Open,
		arg.Owner,
		arg.Ticket,
		arg.Created,
		arg.Updated,
	)
	var i Task
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const insertTicket = `-- name: InsertTicket :one

INSERT INTO tickets (id, name, description, open, owner, resolution, schema, state, type, created, updated)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)
RETURNING created, description, id, name, open, owner, resolution, schema, state, type, updated
`

type InsertTicketParams struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Open        bool   `json:"open"`
	Owner       string `json:"owner"`
	Resolution  string `json:"resolution"`
	Schema      string `json:"schema"`
	State       string `json:"state"`
	Type        string `json:"type"`
	Created     string `json:"created"`
	Updated     string `json:"updated"`
}

// ----------------------------------------------------------------
func (q *WriteQueries) InsertTicket(ctx context.Context, arg InsertTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, insertTicket,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Open,
		arg.Owner,
		arg.Resolution,
		arg.Schema,
		arg.State,
		arg.Type,
		arg.Created,
		arg.Updated,
	)
	var i Ticket
	err := row.Scan(
		&i.Created,
		&i.Description,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Resolution,
		&i.Schema,
		&i.State,
		&i.Type,
		&i.Updated,
	)
	return i, err
}

const insertTimeline = `-- name: InsertTimeline :one

INSERT INTO timeline (id, message, ticket, time, created, updated)
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
RETURNING created, id, message, ticket, time, updated
`

type InsertTimelineParams struct {
	ID      string `json:"id"`
	Message string `json:"message"`
	Ticket  string `json:"ticket"`
	Time    string `json:"time"`
	Created string `json:"created"`
	Updated string `json:"updated"`
}

// ----------------------------------------------------------------
func (q *WriteQueries) InsertTimeline(ctx context.Context, arg InsertTimelineParams) (Timeline, error) {
	row := q.db.QueryRowContext(ctx, insertTimeline,
		arg.ID,
		arg.Message,
		arg.Ticket,
		arg.Time,
		arg.Created,
		arg.Updated,
	)
	var i Timeline
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Time,
		&i.Updated,
	)
	return i, err
}

const insertType = `-- name: InsertType :one

INSERT INTO types (id, singular, plural, icon, schema, created, updated)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)
RETURNING created, icon, id, plural, schema, singular, updated
`

type InsertTypeParams struct {
	ID       string `json:"id"`
	Singular string `json:"singular"`
	Plural   string `json:"plural"`
	Icon     string `json:"icon"`
	Schema   string `json:"schema"`
	Created  string `json:"created"`
	Updated  string `json:"updated"`
}

// ----------------------------------------------------------------
func (q *WriteQueries) InsertType(ctx context.Context, arg InsertTypeParams) (Type, error) {
	row := q.db.QueryRowContext(ctx, insertType,
		arg.ID,
		arg.Singular,
		arg.Plural,
		arg.Icon,
		arg.Schema,
		arg.Created,
		arg.Updated,
	)
	var i Type
	err := row.Scan(
		&i.Created,
		&i.Icon,
		&i.ID,
		&i.Plural,
		&i.Schema,
		&i.Singular,
		&i.Updated,
	)
	return i, err
}

const insertUser = `-- name: InsertUser :one

INSERT INTO users (id, name, email, username, passwordHash, tokenKey, avatar, verified, created, updated)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)
RETURNING avatar, created, email, id, lastresetsentat, lastverificationsentat, name, passwordhash, tokenkey, updated, username, verified
`

type InsertUserParams struct {
	ID           string `json:"id"`
	Name         string `json:"name"`
	Email        string `json:"email"`
	Username     string `json:"username"`
	PasswordHash string `json:"passwordHash"`
	TokenKey     string `json:"tokenKey"`
	Avatar       string `json:"avatar"`
	Verified     bool   `json:"verified"`
	Created      string `json:"created"`
	Updated      string `json:"updated"`
}

// ----------------------------------------------------------------
func (q *WriteQueries) InsertUser(ctx context.Context, arg InsertUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, insertUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Username,
		arg.PasswordHash,
		arg.TokenKey,
		arg.Avatar,
		arg.Verified,
		arg.Created,
		arg.Updated,
	)
	var i User
	err := row.Scan(
		&i.Avatar,
		&i.Created,
		&i.Email,
		&i.ID,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Name,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Updated,
		&i.Username,
		&i.Verified,
	)
	return i, err
}

const insertWebhook = `-- name: InsertWebhook :one

INSERT INTO webhooks (id, name, collection, destination, created, updated)
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
RETURNING collection, created, destination, id, name, updated
`

type InsertWebhookParams struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Collection  string `json:"collection"`
	Destination string `json:"destination"`
	Created     string `json:"created"`
	Updated     string `json:"updated"`
}

// ----------------------------------------------------------------
func (q *WriteQueries) InsertWebhook(ctx context.Context, arg InsertWebhookParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, insertWebhook,
		arg.ID,
		arg.Name,
		arg.Collection,
		arg.Destination,
		arg.Created,
		arg.Updated,
	)
	var i Webhook
	err := row.Scan(
		&i.Collection,
		&i.Created,
		&i.Destination,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const removeGroupFromUser = `-- name: RemoveGroupFromUser :exec
DELETE
FROM user_groups
WHERE user_id = ?1
  AND group_id = ?2
`

type RemoveGroupFromUserParams struct {
	UserID  string `json:"user_id"`
	GroupID string `json:"group_id"`
}

func (q *WriteQueries) RemoveGroupFromUser(ctx context.Context, arg RemoveGroupFromUserParams) error {
	_, err := q.db.ExecContext(ctx, removeGroupFromUser, arg.UserID, arg.GroupID)
	return err
}

const removeParentGroup = `-- name: RemoveParentGroup :exec
DELETE
FROM group_inheritance
WHERE parent_group_id = ?1
  AND child_group_id = ?2
`

type RemoveParentGroupParams struct {
	ParentGroupID string `json:"parent_group_id"`
	ChildGroupID  string `json:"child_group_id"`
}

func (q *WriteQueries) RemoveParentGroup(ctx context.Context, arg RemoveParentGroupParams) error {
	_, err := q.db.ExecContext(ctx, removeParentGroup, arg.ParentGroupID, arg.ChildGroupID)
	return err
}

const updateComment = `-- name: UpdateComment :one
UPDATE comments
SET message = coalesce(?1, message)
WHERE id = ?2
RETURNING author, created, id, message, ticket, updated
`

type UpdateCommentParams struct {
	Message sql.NullString `json:"message"`
	ID      string         `json:"id"`
}

func (q *WriteQueries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, updateComment, arg.Message, arg.ID)
	var i Comment
	err := row.Scan(
		&i.Author,
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const updateFeature = `-- name: UpdateFeature :one
UPDATE features
SET name = coalesce(?1, name)
WHERE id = ?2
RETURNING created, id, name, updated
`

type UpdateFeatureParams struct {
	Name sql.NullString `json:"name"`
	ID   string         `json:"id"`
}

func (q *WriteQueries) UpdateFeature(ctx context.Context, arg UpdateFeatureParams) (Feature, error) {
	row := q.db.QueryRowContext(ctx, updateFeature, arg.Name, arg.ID)
	var i Feature
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}

const updateFile = `-- name: UpdateFile :one
UPDATE files
SET name = coalesce(?1, name),
    blob = coalesce(?2, blob),
    size = coalesce(?3, size)
WHERE id = ?4
RETURNING blob, created, id, name, size, ticket, updated
`

type UpdateFileParams struct {
	Name sql.NullString  `json:"name"`
	Blob sql.NullString  `json:"blob"`
	Size sql.NullFloat64 `json:"size"`
	ID   string          `json:"id"`
}

func (q *WriteQueries) UpdateFile(ctx context.Context, arg UpdateFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, updateFile,
		arg.Name,
		arg.Blob,
		arg.Size,
		arg.ID,
	)
	var i File
	err := row.Scan(
		&i.Blob,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Size,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const updateGroup = `-- name: UpdateGroup :one
UPDATE groups
SET name        = coalesce(?1, name),
    permissions = coalesce(?2, permissions)
WHERE id = ?3
RETURNING id, name, permissions, created, updated
`

type UpdateGroupParams struct {
	Name        sql.NullString `json:"name"`
	Permissions sql.NullString `json:"permissions"`
	ID          string         `json:"id"`
}

func (q *WriteQueries) UpdateGroup(ctx context.Context, arg UpdateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, updateGroup, arg.Name, arg.Permissions, arg.ID)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Permissions,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateLink = `-- name: UpdateLink :one
UPDATE links
SET name = coalesce(?1, name),
    url  = coalesce(?2, url)
WHERE id = ?3
RETURNING created, id, name, ticket, updated, url
`

type UpdateLinkParams struct {
	Name sql.NullString `json:"name"`
	Url  sql.NullString `json:"url"`
	ID   string         `json:"id"`
}

func (q *WriteQueries) UpdateLink(ctx context.Context, arg UpdateLinkParams) (Link, error) {
	row := q.db.QueryRowContext(ctx, updateLink, arg.Name, arg.Url, arg.ID)
	var i Link
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Ticket,
		&i.Updated,
		&i.Url,
	)
	return i, err
}

const updateParam = `-- name: UpdateParam :exec
UPDATE _params
SET value = ?1
WHERE key = ?2
RETURNING id, "key", value, created, updated
`

type UpdateParamParams struct {
	Value string `json:"value"`
	Key   string `json:"key"`
}

func (q *WriteQueries) UpdateParam(ctx context.Context, arg UpdateParamParams) error {
	_, err := q.db.ExecContext(ctx, updateParam, arg.Value, arg.Key)
	return err
}

const updateReaction = `-- name: UpdateReaction :one
UPDATE reactions
SET name        = coalesce(?1, name),
    action      = coalesce(?2, action),
    actiondata  = coalesce(?3, actiondata),
    trigger     = coalesce(?4, trigger),
    triggerdata = coalesce(?5, triggerdata)
WHERE id = ?6
RETURNING "action", actiondata, created, id, name, "trigger", triggerdata, updated
`

type UpdateReactionParams struct {
	Name        sql.NullString `json:"name"`
	Action      sql.NullString `json:"action"`
	Actiondata  string         `json:"actiondata"`
	Trigger     sql.NullString `json:"trigger"`
	Triggerdata string         `json:"triggerdata"`
	ID          string         `json:"id"`
}

func (q *WriteQueries) UpdateReaction(ctx context.Context, arg UpdateReactionParams) (Reaction, error) {
	row := q.db.QueryRowContext(ctx, updateReaction,
		arg.Name,
		arg.Action,
		arg.Actiondata,
		arg.Trigger,
		arg.Triggerdata,
		arg.ID,
	)
	var i Reaction
	err := row.Scan(
		&i.Action,
		&i.Actiondata,
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Trigger,
		&i.Triggerdata,
		&i.Updated,
	)
	return i, err
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks
SET name  = coalesce(?1, name),
    open  = coalesce(?2, open),
    owner = coalesce(?3, owner)
WHERE id = ?4
RETURNING created, id, name, open, owner, ticket, updated
`

type UpdateTaskParams struct {
	Name  sql.NullString `json:"name"`
	Open  sql.NullBool   `json:"open"`
	Owner sql.NullString `json:"owner"`
	ID    string         `json:"id"`
}

func (q *WriteQueries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, updateTask,
		arg.Name,
		arg.Open,
		arg.Owner,
		arg.ID,
	)
	var i Task
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Ticket,
		&i.Updated,
	)
	return i, err
}

const updateTicket = `-- name: UpdateTicket :one
UPDATE tickets
SET name        = coalesce(?1, name),
    description = coalesce(?2, description),
    open        = coalesce(?3, open),
    owner       = coalesce(?4, owner),
    resolution  = coalesce(?5, resolution),
    schema      = coalesce(?6, schema),
    state       = coalesce(?7, state),
    type        = coalesce(?8, type)
WHERE id = ?9
RETURNING created, description, id, name, open, owner, resolution, schema, state, type, updated
`

type UpdateTicketParams struct {
	Name        sql.NullString `json:"name"`
	Description sql.NullString `json:"description"`
	Open        sql.NullBool   `json:"open"`
	Owner       sql.NullString `json:"owner"`
	Resolution  sql.NullString `json:"resolution"`
	Schema      string         `json:"schema"`
	State       string         `json:"state"`
	Type        sql.NullString `json:"type"`
	ID          string         `json:"id"`
}

func (q *WriteQueries) UpdateTicket(ctx context.Context, arg UpdateTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, updateTicket,
		arg.Name,
		arg.Description,
		arg.Open,
		arg.Owner,
		arg.Resolution,
		arg.Schema,
		arg.State,
		arg.Type,
		arg.ID,
	)
	var i Ticket
	err := row.Scan(
		&i.Created,
		&i.Description,
		&i.ID,
		&i.Name,
		&i.Open,
		&i.Owner,
		&i.Resolution,
		&i.Schema,
		&i.State,
		&i.Type,
		&i.Updated,
	)
	return i, err
}

const updateTimeline = `-- name: UpdateTimeline :one
UPDATE timeline
SET message = coalesce(?1, message),
    time    = coalesce(?2, time)
WHERE id = ?3
RETURNING created, id, message, ticket, time, updated
`

type UpdateTimelineParams struct {
	Message sql.NullString `json:"message"`
	Time    sql.NullString `json:"time"`
	ID      string         `json:"id"`
}

func (q *WriteQueries) UpdateTimeline(ctx context.Context, arg UpdateTimelineParams) (Timeline, error) {
	row := q.db.QueryRowContext(ctx, updateTimeline, arg.Message, arg.Time, arg.ID)
	var i Timeline
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Message,
		&i.Ticket,
		&i.Time,
		&i.Updated,
	)
	return i, err
}

const updateType = `-- name: UpdateType :one
UPDATE types
SET singular = coalesce(?1, singular),
    plural   = coalesce(?2, plural),
    icon     = coalesce(?3, icon),
    schema   = coalesce(?4, schema)
WHERE id = ?5
RETURNING created, icon, id, plural, schema, singular, updated
`

type UpdateTypeParams struct {
	Singular sql.NullString `json:"singular"`
	Plural   sql.NullString `json:"plural"`
	Icon     sql.NullString `json:"icon"`
	Schema   string         `json:"schema"`
	ID       string         `json:"id"`
}

func (q *WriteQueries) UpdateType(ctx context.Context, arg UpdateTypeParams) (Type, error) {
	row := q.db.QueryRowContext(ctx, updateType,
		arg.Singular,
		arg.Plural,
		arg.Icon,
		arg.Schema,
		arg.ID,
	)
	var i Type
	err := row.Scan(
		&i.Created,
		&i.Icon,
		&i.ID,
		&i.Plural,
		&i.Schema,
		&i.Singular,
		&i.Updated,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET name                   = coalesce(?1, name),
    email                  = coalesce(?2, email),
    username               = coalesce(?3, username),
    passwordHash           = coalesce(?4, passwordHash),
    tokenKey               = coalesce(?5, tokenKey),
    avatar                 = coalesce(?6, avatar),
    verified               = coalesce(?7, verified),
    lastResetSentAt        = coalesce(?8, lastResetSentAt),
    lastVerificationSentAt = coalesce(?9, lastVerificationSentAt)
WHERE id = ?10
  AND id != 'system'
RETURNING avatar, created, email, id, lastresetsentat, lastverificationsentat, name, passwordhash, tokenkey, updated, username, verified
`

type UpdateUserParams struct {
	Name                   sql.NullString `json:"name"`
	Email                  sql.NullString `json:"email"`
	Username               sql.NullString `json:"username"`
	PasswordHash           sql.NullString `json:"passwordHash"`
	TokenKey               sql.NullString `json:"tokenKey"`
	Avatar                 sql.NullString `json:"avatar"`
	Verified               sql.NullBool   `json:"verified"`
	LastResetSentAt        sql.NullString `json:"lastResetSentAt"`
	LastVerificationSentAt sql.NullString `json:"lastVerificationSentAt"`
	ID                     string         `json:"id"`
}

func (q *WriteQueries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Name,
		arg.Email,
		arg.Username,
		arg.PasswordHash,
		arg.TokenKey,
		arg.Avatar,
		arg.Verified,
		arg.LastResetSentAt,
		arg.LastVerificationSentAt,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.Avatar,
		&i.Created,
		&i.Email,
		&i.ID,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Name,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Updated,
		&i.Username,
		&i.Verified,
	)
	return i, err
}

const updateWebhook = `-- name: UpdateWebhook :one
UPDATE webhooks
SET name        = coalesce(?1, name),
    collection  = coalesce(?2, collection),
    destination = coalesce(?3, destination)
WHERE id = ?4
RETURNING collection, created, destination, id, name, updated
`

type UpdateWebhookParams struct {
	Name        sql.NullString `json:"name"`
	Collection  sql.NullString `json:"collection"`
	Destination sql.NullString `json:"destination"`
	ID          string         `json:"id"`
}

func (q *WriteQueries) UpdateWebhook(ctx context.Context, arg UpdateWebhookParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, updateWebhook,
		arg.Name,
		arg.Collection,
		arg.Destination,
		arg.ID,
	)
	var i Webhook
	err := row.Scan(
		&i.Collection,
		&i.Created,
		&i.Destination,
		&i.ID,
		&i.Name,
		&i.Updated,
	)
	return i, err
}
