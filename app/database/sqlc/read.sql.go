// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: read.sql

package sqlc

import (
	"context"
	"time"
)

const getComment = `-- name: GetComment :one

SELECT comments.id, comments.ticket, comments.author, comments.message, comments.created, comments.updated, users.name as author_name
FROM comments
         LEFT JOIN users ON users.id = comments.author
WHERE comments.id = ?1
`

type GetCommentRow struct {
	ID         string    `json:"id"`
	Ticket     string    `json:"ticket"`
	Author     string    `json:"author"`
	Message    string    `json:"message"`
	Created    time.Time `json:"created"`
	Updated    time.Time `json:"updated"`
	AuthorName *string   `json:"author_name"`
}

// ----------------------------------------------------------------
func (q *ReadQueries) GetComment(ctx context.Context, id string) (GetCommentRow, error) {
	row := q.db.QueryRowContext(ctx, getComment, id)
	var i GetCommentRow
	err := row.Scan(
		&i.ID,
		&i.Ticket,
		&i.Author,
		&i.Message,
		&i.Created,
		&i.Updated,
		&i.AuthorName,
	)
	return i, err
}

const getDashboardCounts = `-- name: GetDashboardCounts :many

SELECT id, count
FROM dashboard_counts
`

// ----------------------------------------------------------------
func (q *ReadQueries) GetDashboardCounts(ctx context.Context) ([]DashboardCount, error) {
	rows, err := q.db.QueryContext(ctx, getDashboardCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DashboardCount
	for rows.Next() {
		var i DashboardCount
		if err := rows.Scan(&i.ID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeature = `-- name: GetFeature :one

SELECT "key"
FROM features
WHERE key = ?1
`

// ----------------------------------------------------------------
func (q *ReadQueries) GetFeature(ctx context.Context, key string) (string, error) {
	row := q.db.QueryRowContext(ctx, getFeature, key)
	err := row.Scan(&key)
	return key, err
}

const getFile = `-- name: GetFile :one

SELECT id, ticket, name, blob, size, created, updated
FROM files
WHERE id = ?1
`

// ----------------------------------------------------------------
func (q *ReadQueries) GetFile(ctx context.Context, id string) (File, error) {
	row := q.db.QueryRowContext(ctx, getFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Ticket,
		&i.Name,
		&i.Blob,
		&i.Size,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getGroup = `-- name: GetGroup :one

SELECT id, name, permissions, created, updated
FROM groups
WHERE id = ?1
`

// ----------------------------------------------------------------
func (q *ReadQueries) GetGroup(ctx context.Context, id string) (Group, error) {
	row := q.db.QueryRowContext(ctx, getGroup, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Permissions,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getLink = `-- name: GetLink :one

SELECT id, ticket, name, url, created, updated
FROM links
WHERE id = ?1
`

// ----------------------------------------------------------------
func (q *ReadQueries) GetLink(ctx context.Context, id string) (Link, error) {
	row := q.db.QueryRowContext(ctx, getLink, id)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.Ticket,
		&i.Name,
		&i.Url,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getReaction = `-- name: GetReaction :one

SELECT id, name, "action", actiondata, "trigger", triggerdata, created, updated
FROM reactions
WHERE id = ?1
`

// ----------------------------------------------------------------
func (q *ReadQueries) GetReaction(ctx context.Context, id string) (Reaction, error) {
	row := q.db.QueryRowContext(ctx, getReaction, id)
	var i Reaction
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Action,
		&i.Actiondata,
		&i.Trigger,
		&i.Triggerdata,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getSidebar = `-- name: GetSidebar :many
SELECT id, singular, plural, icon, count
FROM sidebar
`

func (q *ReadQueries) GetSidebar(ctx context.Context) ([]Sidebar, error) {
	rows, err := q.db.QueryContext(ctx, getSidebar)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sidebar
	for rows.Next() {
		var i Sidebar
		if err := rows.Scan(
			&i.ID,
			&i.Singular,
			&i.Plural,
			&i.Icon,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTask = `-- name: GetTask :one

SELECT tasks.id, tasks.ticket, tasks.owner, tasks.name, tasks.open, tasks.created, tasks.updated, users.name as owner_name, tickets.name as ticket_name, tickets.type as ticket_type
FROM tasks
         LEFT JOIN users ON users.id = tasks.owner
         LEFT JOIN tickets ON tickets.id = tasks.ticket
WHERE tasks.id = ?1
`

type GetTaskRow struct {
	ID         string    `json:"id"`
	Ticket     string    `json:"ticket"`
	Owner      *string   `json:"owner"`
	Name       string    `json:"name"`
	Open       bool      `json:"open"`
	Created    time.Time `json:"created"`
	Updated    time.Time `json:"updated"`
	OwnerName  *string   `json:"owner_name"`
	TicketName *string   `json:"ticket_name"`
	TicketType *string   `json:"ticket_type"`
}

// ----------------------------------------------------------------
func (q *ReadQueries) GetTask(ctx context.Context, id string) (GetTaskRow, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i GetTaskRow
	err := row.Scan(
		&i.ID,
		&i.Ticket,
		&i.Owner,
		&i.Name,
		&i.Open,
		&i.Created,
		&i.Updated,
		&i.OwnerName,
		&i.TicketName,
		&i.TicketType,
	)
	return i, err
}

const getTimeline = `-- name: GetTimeline :one

SELECT id, ticket, message, time, created, updated
FROM timeline
WHERE id = ?1
`

// ----------------------------------------------------------------
func (q *ReadQueries) GetTimeline(ctx context.Context, id string) (Timeline, error) {
	row := q.db.QueryRowContext(ctx, getTimeline, id)
	var i Timeline
	err := row.Scan(
		&i.ID,
		&i.Ticket,
		&i.Message,
		&i.Time,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getType = `-- name: GetType :one

SELECT id, icon, singular, plural, schema, created, updated
FROM types
WHERE id = ?1
`

// ----------------------------------------------------------------
func (q *ReadQueries) GetType(ctx context.Context, id string) (Type, error) {
	row := q.db.QueryRowContext(ctx, getType, id)
	var i Type
	err := row.Scan(
		&i.ID,
		&i.Icon,
		&i.Singular,
		&i.Plural,
		&i.Schema,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getUser = `-- name: GetUser :one

SELECT id, username, passwordhash, tokenkey, active, name, email, avatar, lastresetsentat, lastverificationsentat, created, updated
FROM users
WHERE id = ?1
`

// ----------------------------------------------------------------
func (q *ReadQueries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Active,
		&i.Name,
		&i.Email,
		&i.Avatar,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getWebhook = `-- name: GetWebhook :one

SELECT id, collection, destination, name, created, updated
FROM webhooks
WHERE id = ?1
`

// ----------------------------------------------------------------
func (q *ReadQueries) GetWebhook(ctx context.Context, id string) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, getWebhook, id)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.Collection,
		&i.Destination,
		&i.Name,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const listChildGroups = `-- name: ListChildGroups :many
SELECT g.id, g.name, g.permissions, g.created, g.updated, group_effective_groups.group_type
FROM group_effective_groups
         JOIN groups AS g ON g.id = group_effective_groups.parent_group_id
WHERE child_group_id = ?1
ORDER BY group_effective_groups.group_type
`

type ListChildGroupsRow struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Permissions string    `json:"permissions"`
	Created     time.Time `json:"created"`
	Updated     time.Time `json:"updated"`
	GroupType   string    `json:"group_type"`
}

func (q *ReadQueries) ListChildGroups(ctx context.Context, groupID string) ([]ListChildGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, listChildGroups, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChildGroupsRow
	for rows.Next() {
		var i ListChildGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Permissions,
			&i.Created,
			&i.Updated,
			&i.GroupType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listComments = `-- name: ListComments :many
SELECT comments.id, comments.ticket, comments.author, comments.message, comments.created, comments.updated, users.name as author_name, COUNT(*) OVER () as total_count
FROM comments
         LEFT JOIN users ON users.id = comments.author
WHERE ticket = ?1
   OR ?1 = ''
ORDER BY comments.created DESC
LIMIT ?3 OFFSET ?2
`

type ListCommentsParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

type ListCommentsRow struct {
	ID         string    `json:"id"`
	Ticket     string    `json:"ticket"`
	Author     string    `json:"author"`
	Message    string    `json:"message"`
	Created    time.Time `json:"created"`
	Updated    time.Time `json:"updated"`
	AuthorName *string   `json:"author_name"`
	TotalCount int64     `json:"total_count"`
}

func (q *ReadQueries) ListComments(ctx context.Context, arg ListCommentsParams) ([]ListCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listComments, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCommentsRow
	for rows.Next() {
		var i ListCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Ticket,
			&i.Author,
			&i.Message,
			&i.Created,
			&i.Updated,
			&i.AuthorName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeatures = `-- name: ListFeatures :many
SELECT features."key", COUNT(*) OVER () as total_count
FROM features
ORDER BY features.key DESC
LIMIT ?2 OFFSET ?1
`

type ListFeaturesParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListFeaturesRow struct {
	Key        string `json:"key"`
	TotalCount int64  `json:"total_count"`
}

func (q *ReadQueries) ListFeatures(ctx context.Context, arg ListFeaturesParams) ([]ListFeaturesRow, error) {
	rows, err := q.db.QueryContext(ctx, listFeatures, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeaturesRow
	for rows.Next() {
		var i ListFeaturesRow
		if err := rows.Scan(&i.Key, &i.TotalCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFiles = `-- name: ListFiles :many
SELECT files.id, files.ticket, files.name, files.blob, files.size, files.created, files.updated, COUNT(*) OVER () as total_count
FROM files
WHERE ticket = ?1
   OR ?1 = ''
ORDER BY files.created DESC
LIMIT ?3 OFFSET ?2
`

type ListFilesParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

type ListFilesRow struct {
	ID         string    `json:"id"`
	Ticket     string    `json:"ticket"`
	Name       string    `json:"name"`
	Blob       string    `json:"blob"`
	Size       float64   `json:"size"`
	Created    time.Time `json:"created"`
	Updated    time.Time `json:"updated"`
	TotalCount int64     `json:"total_count"`
}

func (q *ReadQueries) ListFiles(ctx context.Context, arg ListFilesParams) ([]ListFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listFiles, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFilesRow
	for rows.Next() {
		var i ListFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.Ticket,
			&i.Name,
			&i.Blob,
			&i.Size,
			&i.Created,
			&i.Updated,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupUsers = `-- name: ListGroupUsers :many
SELECT users.id, users.username, users.passwordhash, users.tokenkey, users.active, users.name, users.email, users.avatar, users.lastresetsentat, users.lastverificationsentat, users.created, users.updated, uer.group_type
FROM user_effective_groups uer
         JOIN users ON users.id = uer.user_id
WHERE uer.group_id = ?1
ORDER BY users.name DESC
`

type ListGroupUsersRow struct {
	ID                     string     `json:"id"`
	Username               string     `json:"username"`
	Passwordhash           string     `json:"passwordhash"`
	Tokenkey               string     `json:"tokenkey"`
	Active                 bool       `json:"active"`
	Name                   *string    `json:"name"`
	Email                  *string    `json:"email"`
	Avatar                 *string    `json:"avatar"`
	Lastresetsentat        *time.Time `json:"lastresetsentat"`
	Lastverificationsentat *time.Time `json:"lastverificationsentat"`
	Created                time.Time  `json:"created"`
	Updated                time.Time  `json:"updated"`
	GroupType              string     `json:"group_type"`
}

func (q *ReadQueries) ListGroupUsers(ctx context.Context, groupID string) ([]ListGroupUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listGroupUsers, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGroupUsersRow
	for rows.Next() {
		var i ListGroupUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Passwordhash,
			&i.Tokenkey,
			&i.Active,
			&i.Name,
			&i.Email,
			&i.Avatar,
			&i.Lastresetsentat,
			&i.Lastverificationsentat,
			&i.Created,
			&i.Updated,
			&i.GroupType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroups = `-- name: ListGroups :many
SELECT g.id, g.name, g.permissions, g.created, g.updated, COUNT(*) OVER () as total_count
FROM groups AS g
ORDER BY g.created DESC
LIMIT ?2 OFFSET ?1
`

type ListGroupsParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListGroupsRow struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Permissions string    `json:"permissions"`
	Created     time.Time `json:"created"`
	Updated     time.Time `json:"updated"`
	TotalCount  int64     `json:"total_count"`
}

func (q *ReadQueries) ListGroups(ctx context.Context, arg ListGroupsParams) ([]ListGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, listGroups, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGroupsRow
	for rows.Next() {
		var i ListGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Permissions,
			&i.Created,
			&i.Updated,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinks = `-- name: ListLinks :many
SELECT links.id, links.ticket, links.name, links.url, links.created, links.updated, COUNT(*) OVER () as total_count
FROM links
WHERE ticket = ?1
   OR ?1 = ''
ORDER BY links.created DESC
LIMIT ?3 OFFSET ?2
`

type ListLinksParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

type ListLinksRow struct {
	ID         string    `json:"id"`
	Ticket     string    `json:"ticket"`
	Name       string    `json:"name"`
	Url        string    `json:"url"`
	Created    time.Time `json:"created"`
	Updated    time.Time `json:"updated"`
	TotalCount int64     `json:"total_count"`
}

func (q *ReadQueries) ListLinks(ctx context.Context, arg ListLinksParams) ([]ListLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, listLinks, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLinksRow
	for rows.Next() {
		var i ListLinksRow
		if err := rows.Scan(
			&i.ID,
			&i.Ticket,
			&i.Name,
			&i.Url,
			&i.Created,
			&i.Updated,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listParentGroups = `-- name: ListParentGroups :many
SELECT g.id, g.name, g.permissions, g.created, g.updated, group_effective_groups.group_type
FROM group_effective_groups
         JOIN groups AS g ON g.id = group_effective_groups.child_group_id
WHERE parent_group_id = ?1
ORDER BY group_effective_groups.group_type
`

type ListParentGroupsRow struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Permissions string    `json:"permissions"`
	Created     time.Time `json:"created"`
	Updated     time.Time `json:"updated"`
	GroupType   string    `json:"group_type"`
}

func (q *ReadQueries) ListParentGroups(ctx context.Context, groupID string) ([]ListParentGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, listParentGroups, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListParentGroupsRow
	for rows.Next() {
		var i ListParentGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Permissions,
			&i.Created,
			&i.Updated,
			&i.GroupType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listParentPermissions = `-- name: ListParentPermissions :many
SELECT group_effective_permissions.permission
FROM group_effective_permissions
WHERE parent_group_id = ?1
ORDER BY permission
`

func (q *ReadQueries) ListParentPermissions(ctx context.Context, groupID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listParentPermissions, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var permission string
		if err := rows.Scan(&permission); err != nil {
			return nil, err
		}
		items = append(items, permission)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReactions = `-- name: ListReactions :many
SELECT reactions.id, reactions.name, reactions."action", reactions.actiondata, reactions."trigger", reactions.triggerdata, reactions.created, reactions.updated, COUNT(*) OVER () as total_count
FROM reactions
ORDER BY reactions.created DESC
LIMIT ?2 OFFSET ?1
`

type ListReactionsParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListReactionsRow struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Action      string    `json:"action"`
	Actiondata  []byte    `json:"actiondata"`
	Trigger     string    `json:"trigger"`
	Triggerdata []byte    `json:"triggerdata"`
	Created     time.Time `json:"created"`
	Updated     time.Time `json:"updated"`
	TotalCount  int64     `json:"total_count"`
}

func (q *ReadQueries) ListReactions(ctx context.Context, arg ListReactionsParams) ([]ListReactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listReactions, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListReactionsRow
	for rows.Next() {
		var i ListReactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Action,
			&i.Actiondata,
			&i.Trigger,
			&i.Triggerdata,
			&i.Created,
			&i.Updated,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT tasks.id, tasks.ticket, tasks.owner, tasks.name, tasks.open, tasks.created, tasks.updated,
       users.name       as owner_name,
       tickets.name     as ticket_name,
       tickets.type     as ticket_type,
       COUNT(*) OVER () as total_count
FROM tasks
         LEFT JOIN users ON users.id = tasks.owner
         LEFT JOIN tickets ON tickets.id = tasks.ticket
WHERE ticket = ?1
   OR ?1 = ''
ORDER BY tasks.created DESC
LIMIT ?3 OFFSET ?2
`

type ListTasksParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

type ListTasksRow struct {
	ID         string    `json:"id"`
	Ticket     string    `json:"ticket"`
	Owner      *string   `json:"owner"`
	Name       string    `json:"name"`
	Open       bool      `json:"open"`
	Created    time.Time `json:"created"`
	Updated    time.Time `json:"updated"`
	OwnerName  *string   `json:"owner_name"`
	TicketName *string   `json:"ticket_name"`
	TicketType *string   `json:"ticket_type"`
	TotalCount int64     `json:"total_count"`
}

func (q *ReadQueries) ListTasks(ctx context.Context, arg ListTasksParams) ([]ListTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, listTasks, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksRow
	for rows.Next() {
		var i ListTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.Ticket,
			&i.Owner,
			&i.Name,
			&i.Open,
			&i.Created,
			&i.Updated,
			&i.OwnerName,
			&i.TicketName,
			&i.TicketType,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTickets = `-- name: ListTickets :many
SELECT tickets.id, tickets.type, tickets.owner, tickets.name, tickets.description, tickets.open, tickets.resolution, tickets.schema, tickets.state, tickets.created, tickets.updated,
       users.name       as owner_name,
       types.singular   as type_singular,
       types.plural     as type_plural,
       COUNT(*) OVER () as total_count
FROM tickets
         LEFT JOIN users ON users.id = tickets.owner
         LEFT JOIN types ON types.id = tickets.type
ORDER BY tickets.created DESC
LIMIT ?2 OFFSET ?1
`

type ListTicketsParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListTicketsRow struct {
	ID           string    `json:"id"`
	Type         string    `json:"type"`
	Owner        *string   `json:"owner"`
	Name         string    `json:"name"`
	Description  string    `json:"description"`
	Open         bool      `json:"open"`
	Resolution   *string   `json:"resolution"`
	Schema       []byte    `json:"schema"`
	State        []byte    `json:"state"`
	Created      time.Time `json:"created"`
	Updated      time.Time `json:"updated"`
	OwnerName    *string   `json:"owner_name"`
	TypeSingular *string   `json:"type_singular"`
	TypePlural   *string   `json:"type_plural"`
	TotalCount   int64     `json:"total_count"`
}

func (q *ReadQueries) ListTickets(ctx context.Context, arg ListTicketsParams) ([]ListTicketsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTickets, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTicketsRow
	for rows.Next() {
		var i ListTicketsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Owner,
			&i.Name,
			&i.Description,
			&i.Open,
			&i.Resolution,
			&i.Schema,
			&i.State,
			&i.Created,
			&i.Updated,
			&i.OwnerName,
			&i.TypeSingular,
			&i.TypePlural,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTimeline = `-- name: ListTimeline :many
SELECT timeline.id, timeline.ticket, timeline.message, timeline.time, timeline.created, timeline.updated, COUNT(*) OVER () as total_count
FROM timeline
WHERE ticket = ?1
   OR ?1 = ''
ORDER BY timeline.created DESC
LIMIT ?3 OFFSET ?2
`

type ListTimelineParams struct {
	Ticket string `json:"ticket"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

type ListTimelineRow struct {
	ID         string    `json:"id"`
	Ticket     string    `json:"ticket"`
	Message    string    `json:"message"`
	Time       time.Time `json:"time"`
	Created    time.Time `json:"created"`
	Updated    time.Time `json:"updated"`
	TotalCount int64     `json:"total_count"`
}

func (q *ReadQueries) ListTimeline(ctx context.Context, arg ListTimelineParams) ([]ListTimelineRow, error) {
	rows, err := q.db.QueryContext(ctx, listTimeline, arg.Ticket, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTimelineRow
	for rows.Next() {
		var i ListTimelineRow
		if err := rows.Scan(
			&i.ID,
			&i.Ticket,
			&i.Message,
			&i.Time,
			&i.Created,
			&i.Updated,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTypes = `-- name: ListTypes :many
SELECT types.id, types.icon, types.singular, types.plural, types.schema, types.created, types.updated, COUNT(*) OVER () as total_count
FROM types
ORDER BY created DESC
LIMIT ?2 OFFSET ?1
`

type ListTypesParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListTypesRow struct {
	ID         string    `json:"id"`
	Icon       *string   `json:"icon"`
	Singular   string    `json:"singular"`
	Plural     string    `json:"plural"`
	Schema     []byte    `json:"schema"`
	Created    time.Time `json:"created"`
	Updated    time.Time `json:"updated"`
	TotalCount int64     `json:"total_count"`
}

func (q *ReadQueries) ListTypes(ctx context.Context, arg ListTypesParams) ([]ListTypesRow, error) {
	rows, err := q.db.QueryContext(ctx, listTypes, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTypesRow
	for rows.Next() {
		var i ListTypesRow
		if err := rows.Scan(
			&i.ID,
			&i.Icon,
			&i.Singular,
			&i.Plural,
			&i.Schema,
			&i.Created,
			&i.Updated,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserGroups = `-- name: ListUserGroups :many
SELECT g.id, g.name, g.permissions, g.created, g.updated, uer.group_type, COUNT(*) OVER () as total_count
FROM user_effective_groups uer
         JOIN groups AS g ON g.id = uer.group_id
WHERE uer.user_id = ?1
ORDER BY g.name DESC
`

type ListUserGroupsRow struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Permissions string    `json:"permissions"`
	Created     time.Time `json:"created"`
	Updated     time.Time `json:"updated"`
	GroupType   string    `json:"group_type"`
	TotalCount  int64     `json:"total_count"`
}

func (q *ReadQueries) ListUserGroups(ctx context.Context, userID string) ([]ListUserGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserGroups, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserGroupsRow
	for rows.Next() {
		var i ListUserGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Permissions,
			&i.Created,
			&i.Updated,
			&i.GroupType,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserPermissions = `-- name: ListUserPermissions :many
SELECT user_effective_permissions.permission
FROM user_effective_permissions
WHERE user_id = ?1
ORDER BY permission
`

func (q *ReadQueries) ListUserPermissions(ctx context.Context, userID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listUserPermissions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var permission string
		if err := rows.Scan(&permission); err != nil {
			return nil, err
		}
		items = append(items, permission)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT users.id, users.username, users.passwordhash, users.tokenkey, users.active, users.name, users.email, users.avatar, users.lastresetsentat, users.lastverificationsentat, users.created, users.updated, COUNT(*) OVER () as total_count
FROM users
WHERE id != 'system'
ORDER BY users.created DESC
LIMIT ?2 OFFSET ?1
`

type ListUsersParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListUsersRow struct {
	ID                     string     `json:"id"`
	Username               string     `json:"username"`
	Passwordhash           string     `json:"passwordhash"`
	Tokenkey               string     `json:"tokenkey"`
	Active                 bool       `json:"active"`
	Name                   *string    `json:"name"`
	Email                  *string    `json:"email"`
	Avatar                 *string    `json:"avatar"`
	Lastresetsentat        *time.Time `json:"lastresetsentat"`
	Lastverificationsentat *time.Time `json:"lastverificationsentat"`
	Created                time.Time  `json:"created"`
	Updated                time.Time  `json:"updated"`
	TotalCount             int64      `json:"total_count"`
}

func (q *ReadQueries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Passwordhash,
			&i.Tokenkey,
			&i.Active,
			&i.Name,
			&i.Email,
			&i.Avatar,
			&i.Lastresetsentat,
			&i.Lastverificationsentat,
			&i.Created,
			&i.Updated,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooks = `-- name: ListWebhooks :many
SELECT webhooks.id, webhooks.collection, webhooks.destination, webhooks.name, webhooks.created, webhooks.updated, COUNT(*) OVER () as total_count
FROM webhooks
ORDER BY created DESC
LIMIT ?2 OFFSET ?1
`

type ListWebhooksParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListWebhooksRow struct {
	ID          string    `json:"id"`
	Collection  string    `json:"collection"`
	Destination string    `json:"destination"`
	Name        string    `json:"name"`
	Created     time.Time `json:"created"`
	Updated     time.Time `json:"updated"`
	TotalCount  int64     `json:"total_count"`
}

func (q *ReadQueries) ListWebhooks(ctx context.Context, arg ListWebhooksParams) ([]ListWebhooksRow, error) {
	rows, err := q.db.QueryContext(ctx, listWebhooks, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWebhooksRow
	for rows.Next() {
		var i ListWebhooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Collection,
			&i.Destination,
			&i.Name,
			&i.Created,
			&i.Updated,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const param = `-- name: Param :one
SELECT "key", value
FROM _params
WHERE _params.key = ?1
`

func (q *ReadQueries) Param(ctx context.Context, key string) (Param, error) {
	row := q.db.QueryRowContext(ctx, param, key)
	var i Param
	err := row.Scan(&i.Key, &i.Value)
	return i, err
}

const searchTickets = `-- name: SearchTickets :many
SELECT id,
       name,
       created,
       description,
       open,
       type,
       state,
       owner_name,
       COUNT(*) OVER () as total_count
FROM ticket_search
WHERE (?1 = '' OR (name LIKE '%' || ?1 || '%'
    OR description LIKE '%' || ?1 || '%'
    OR comment_messages LIKE '%' || ?1 || '%'
    OR file_names LIKE '%' || ?1 || '%'
    OR link_names LIKE '%' || ?1 || '%'
    OR link_urls LIKE '%' || ?1 || '%'
    OR task_names LIKE '%' || ?1 || '%'
    OR timeline_messages LIKE '%' || ?1 || '%'))
  AND (?2 IS NULL OR type = ?2)
  AND (?3 IS NULL OR open = ?3)
ORDER BY created DESC
LIMIT ?5 OFFSET ?4
`

type SearchTicketsParams struct {
	Query  interface{} `json:"query"`
	Type   interface{} `json:"type"`
	Open   interface{} `json:"open"`
	Offset int64       `json:"offset"`
	Limit  int64       `json:"limit"`
}

type SearchTicketsRow struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Created     time.Time `json:"created"`
	Description string    `json:"description"`
	Open        bool      `json:"open"`
	Type        string    `json:"type"`
	State       []byte    `json:"state"`
	OwnerName   *string   `json:"owner_name"`
	TotalCount  int64     `json:"total_count"`
}

func (q *ReadQueries) SearchTickets(ctx context.Context, arg SearchTicketsParams) ([]SearchTicketsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchTickets,
		arg.Query,
		arg.Type,
		arg.Open,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchTicketsRow
	for rows.Next() {
		var i SearchTicketsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Description,
			&i.Open,
			&i.Type,
			&i.State,
			&i.OwnerName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemUser = `-- name: SystemUser :one
SELECT id, username, passwordhash, tokenkey, active, name, email, avatar, lastresetsentat, lastverificationsentat, created, updated
FROM users
WHERE id = 'system'
`

func (q *ReadQueries) SystemUser(ctx context.Context) (User, error) {
	row := q.db.QueryRowContext(ctx, systemUser)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Active,
		&i.Name,
		&i.Email,
		&i.Avatar,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const ticket = `-- name: Ticket :one

SELECT tickets.id, tickets.type, tickets.owner, tickets.name, tickets.description, tickets.open, tickets.resolution, tickets.schema, tickets.state, tickets.created, tickets.updated, users.name as owner_name, types.singular as type_singular, types.plural as type_plural
FROM tickets
         LEFT JOIN users ON users.id = tickets.owner
         LEFT JOIN types ON types.id = tickets.type
WHERE tickets.id = ?1
`

type TicketRow struct {
	ID           string    `json:"id"`
	Type         string    `json:"type"`
	Owner        *string   `json:"owner"`
	Name         string    `json:"name"`
	Description  string    `json:"description"`
	Open         bool      `json:"open"`
	Resolution   *string   `json:"resolution"`
	Schema       []byte    `json:"schema"`
	State        []byte    `json:"state"`
	Created      time.Time `json:"created"`
	Updated      time.Time `json:"updated"`
	OwnerName    *string   `json:"owner_name"`
	TypeSingular *string   `json:"type_singular"`
	TypePlural   *string   `json:"type_plural"`
}

// -----------------------------------------------------------------
func (q *ReadQueries) Ticket(ctx context.Context, id string) (TicketRow, error) {
	row := q.db.QueryRowContext(ctx, ticket, id)
	var i TicketRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Owner,
		&i.Name,
		&i.Description,
		&i.Open,
		&i.Resolution,
		&i.Schema,
		&i.State,
		&i.Created,
		&i.Updated,
		&i.OwnerName,
		&i.TypeSingular,
		&i.TypePlural,
	)
	return i, err
}

const userByEmail = `-- name: UserByEmail :one
SELECT id, username, passwordhash, tokenkey, active, name, email, avatar, lastresetsentat, lastverificationsentat, created, updated
FROM users
WHERE email = ?1
`

func (q *ReadQueries) UserByEmail(ctx context.Context, email *string) (User, error) {
	row := q.db.QueryRowContext(ctx, userByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Active,
		&i.Name,
		&i.Email,
		&i.Avatar,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const userByUserName = `-- name: UserByUserName :one
SELECT id, username, passwordhash, tokenkey, active, name, email, avatar, lastresetsentat, lastverificationsentat, created, updated
FROM users
WHERE username = ?1
`

func (q *ReadQueries) UserByUserName(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, userByUserName, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Passwordhash,
		&i.Tokenkey,
		&i.Active,
		&i.Name,
		&i.Email,
		&i.Avatar,
		&i.Lastresetsentat,
		&i.Lastverificationsentat,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
